# 理解pythonic

Pythonic 就是充分体现python自身特色的代码风格。

## 代码风格

在语法上，代码风格要充分表现 Python 自身特色。比如说两个变量交换`a, b = b, a`. 再比如遍历容器：`for in `, 或者说with语法。写出的代码带着python味，而不是看着像C或者JAVA等

# 编写pythonic

## 避免劣化代码

劣化代码指的是一开始写出来的代码就是不合理的

1. 推荐变量名和要解决的问题一致
2. 不要害怕过长的变量名

## PEP8

pep8是一种规范，同时也有一个pep8程序可以检测程序是否符合规范。

`pip install -U pycodestyle`

常用：

```python
pycodestyle --first
pycodestyle --statistics -qq
pycodestyle --show-source  --show-pep8
```

# 添加适当注释

1. 使用块注释和行注释注释那些复杂的操作、算法
2. 给函数和类写文档注释
3. 注释不可与代码重复，注释是解释代码的想法的
4. 不能用注释快速删除代码，要想保留代码可以使用版本管理工具

#  适当使用空行

开发人员应该写出布局清晰、整洁、优雅的代码。其中布局是比较重要的一部分。

类的方法用一个空行分割，类和类(函数)之间用两个空行分割，一个函数(方法)的不同逻辑也需要用一个空行分割，至于怎么判别是不同逻辑和布局看经验(比如if等都放在一个代码段)

#  建议五：编写函数的4个原则

1. 函数设计尽量短小
2. 函数参数不宜过多，过多的参数也会给测试带来麻烦
3. 函数参数设计应该考虑向下兼容(如参数默认值)
4. 一个函数只做一件事，颗粒性(可以用动词来分割)

尽量不要使用可变对象作为默认值，使用异常替换返回错误，保证通过单元测试等

#  把常量集中到一个文件

自定义简单的const

```python
import sys


class ConstError(Exception):
    def __init__(self, msg, *args, **kwargs):
        self.msg = msg
        super(ConstError, self).__init__(*args, **kwargs)

    def __str__(self):
        return str(self.msg)


class Const(object):

    def __setattr__(self, key, value):
        assert key.isupper(), (1, "{}must be upper".format(key))
        if key in self.__dict__:
            raise ConstError("cannot modify const value")
        self.__dict__[key] = value

    def __getattr__(self, key):
        return self.__dict__.get(key)


sys.modules[__name__] = Const()
```

py文件名命名为const即可使用。

# 利用 assert 语句来发现问题

断言是用来捕获用户所定义的约束的，而不是用来捕获程序本身的错误的。

不用断言：

1. 如果 Python 本身的异常能够处理就不要再使用断言。如对于类似于数组越界、类型不匹配、除数为 0 之类的错误，不建议使用断言来进行处理
2. 不要使用断言来检查用户的输入。如对于一个数字类型，如果根据用户的设计该值的范围应该是 2~10，较好的做法是使用条件判断，并在不符合条件的时候输出错误提示信息

使用断言：

1. 在函数调用后，当需要确认返回值是否合理时可以使用断言
2. 当条件是业务逻辑继续下去的先决条件时可以使用断言

python -O test.py: -O参数可以不检查断言，因为断言会有性能的损耗

# 数据交换的时候不推荐使用中间变量

```python
from timeit import timeit
print(timeit("temp = x; x = y; y = temp", "x=2;y=3", number=1000))
print(timeit("x,y=y,x", "x=2;y=3", number=1000))
```

`x,y = y,x`=>`x,y = (y,x)`  利用元组的解包

# 充分利用 Lazy evaluation 的特性

Lazy evaluation 常被译为“延迟计算”或“惰性计算”，指的是仅仅在真正需要执行的时候才计算表达式的值。充分利用 Lazy evaluation 的特性带来的好处主要体现在以下两个方面：

1. 避免不必要的计算，带来性能上的提升。对于 Python 中的条件表达式 `if x and y`，在 x 为 false 的情况下 y 表达式的值将不再计算。而对于 `if x or y`，当 x 的值为 true 的时候将直接返回，不再计算 y 的值。因此编程中应该充分利用该特性。对于 or 条件表达式应该将值为真可能性较高的变量写在 or 的前面，而 and 则应该推后。
2. 节省空间，使得无限循环的数据结构成为可能。Python 中最典型的使用延迟计算的例子就是生成器表达式了

# 不推荐使用 type 来进行类型检查

内建函数 `type(object)` 用于返回当前对象的类型，因此可以通过与 Python 自带模块 types 中所定义的名称进行比较，根据其返回值确定变量类型是否符合要求。python2的type和python3的type不太一样，python2和python3的types模块也不太一样。在python2中：

```python
class A:
    pass

class B:
    pass

a = A()
b = B()
```

`type(a) == type(b)` 但是在python3中就不成立，为了一致性，推荐使用isinstance内置函数。

# 警惕 `eval()` 的安全漏洞

eval(expression, globals=None, locals=None)  --- 官方文档中的解释是，将字符串str当成有效的表达式来求值并返回计算结果。globals和locals参数是可选的，如果提供了globals参数，那么它必须是dictionary类型；如果提供了locals参数，那么它可以是任意的map对象。

python是用命名空间来记录变量的轨迹的，命名空间是一个dictionary，键是变量名，值是变量值。

当一行代码要使用变量 `x` 的值时，Python 会到所有可用的名字空间去查找变量，按照如下顺序:

1. 局部名字空间 - 特指当前函数或类的方法。如果函数定义了一个局部变量 `x`, 或一个参数 `x`，Python 将使用它，然后停止搜索。
2. 全局名字空间 - 特指当前的模块。如果模块定义了一个名为 `x` 的变量，函数或类，Python 将使用它然后停止搜索。
3. 内置名字空间 - 对每个模块都是全局的。作为最后的尝试，Python 将假设 `x` 是内置函数或变量。

python的全局名字空间存储在一个叫globals()的dict对象中；局部名字空间存储在一个叫locals()的dict对象中。我们可以用print (locals())来查看该函数体内的所有变量名和变量值。其中，locals()对象的值不能修改，globals()对象的值可以修改.

eval有安全性问题,比如用户恶意输入就会获得当前目录文件:`eval("__import__('os').system('ls')")`

推荐使用ast.literal_eval()替换内置的eval,.计算操作，及危险操作，如果换成了ast.literal_eval()，都会拒绝执行.

```python
In [9]: eval("__import__('os').system('ls')")
Desktop         Downloads       Movies          Pictures        Public          VirtualBox VMs  data            dotfiles        go              node_modules    venv36
Documents       Library         Music           PromotionRes    PycharmProjects a.py            develop         git             handfile        venv27
Out[9]: 0

In [10]: ast.literal_eval("__import__('os').system('ls')")
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-10-d66e749f158c> in <module>()
----> 1 ast.literal_eval("__import__('os').system('ls')")

/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/ast.py in literal_eval(node_or_string)
     83                     return left - right
     84         raise ValueError('malformed node or string: ' + repr(node))
---> 85     return _convert(node_or_string)
     86
     87

/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/ast.py in _convert(node)
     82                 else:
     83                     return left - right
---> 84         raise ValueError('malformed node or string: ' + repr(node))
     85     return _convert(node_or_string)
     86

ValueError: malformed node or string: <_ast.Call object at 0x105efd278>
```

# 使用 `enumerate()` 获取序列迭代的索引和值

函数 `enumerate()`，主要是为了解决在循环中获取索引以及对应值的问题。它具有一定的惰性（lazy），每次仅在需要的时候才会产生一个（index, item）对

# 考虑兼容性，尽可能使用 Unicode

考虑兼容性一般在python文件开头加上这么一句：`from __future__ import unicode_literals` 用于处理python2的字符串和python3的不统一.这样在py2下, '你好'这样的字符串不用加前缀u, 也是unicode编码.

在python3中默认的编码采用了unicode, 并取消了前缀u. 如果代码要兼容python2/3, 就很麻烦了.加python版本判断, if sys.version < '3', 字符串不加前缀u, 如果是py2, 加上前缀u. 这样代码显得很拖沓. 

在py2中，对于str类型的字符串，调用len()和遍历时，其实都是以字节为单位的，
对unicode类型的字符串调用len()和遍历才是以字符为单位，这是我们所要的。　另外，Django，Django REST framework的接口都是返回unicode类型的字符串。

# python中的枚举

```python
from enum import Enum, unique

@unique
class Color(Enum):
    red = 1
    orange = 2
    yellow = 3
    green = 4
    blue = 5
    indigo = 6
    purple = 7
```

- 颜色枚举有7个成员，分别是Color.red、Color.orange、Color.yellow等。
- 每一个成员都有它们各自名称和值，Color.red成员的名称是：red，值是：1

细节：

1. 成员名称不能重复
2. 默认情况下, 不同的成员的值可以相同，只不过后面的当做前面的别名(要想不同可以加unique装饰器)。通过值枚举时只能取到第一个枚举变量
3. `for color in Color` : 只获取重复成员的第一个成员，要想获得所有成员：`for color in Color.__members__.items()`
4. 枚举成员有name和value两种属性，Color["red"] 或 Color(1)
5. 枚举成员可以进行等值比较，不能进行大小比较.

也可以使用collections.namedtuple 来模拟枚举操作(元组不能进行修改)

# 有节制地使用 `from ... import` 语句

Python 提供了 3 种方式来引入外部模块：`import` 语句、`from ... import ...` 及 `__import__` 函数。其中较为常见的为前面两种，而 `__import__` 函数与 `import` 语句类似，不同点在于前者显式地将模块的名称作为字符串传递并赋值给命名空间的变量。

在使用 `import` 的时候注意以下几点：

- 一般情况下尽量优先使用 `import a` 形式
- 有节制地使用 `from a import B` 形式
- 尽量避免使用 `from a import *`，因为这会污染命名空间

有节制地使用`from a import B`的说明：

1.命名空间的冲突(多个文件定义的函数名一致)

2.循环嵌套导入

```python
# c2.py
from c1 import g

def x():
    pass
```

```python
# c1.py
from c2 import x

def g():
    pass
```

## python import 的步骤

python 所有加载的模块信息都存放在 `sys.modules` 结构中，当 import 一个模块时，会按如下步骤来进行

- 如果是 `import A`，检查 sys.modules 中是否已经有 A，如果有则不加载，如果没有则为 A 创建 module 对象，并加载 A
- 如果是 `from A import B`，先为 A 创建 module 对象，再解析A，从中寻找B并填充到 A 的 `__dict__`中

## sys.modules 与sys.path

python在import包的时候会从列表sys.path依次去寻找，寻找到就会把包名和包对象放在字典sys.modules里，有了sys.modules这样我们就能在程序使用导入的包的代码了(从字典sys.modules去寻找包对象)。

## python -m

区分运行python脚本的两种方式：

1. python xx.py
2. python -m xx

`python -m xx` 表示把xx当做模块来启动，__但是__`__name__`的值依旧为`__main__`.不同的加载py文件的方式，主要是影响sys.path 这个属性。sys.path 就相当于liunx中的PATH。

1. 直接启动是把xx.py文件所在的目录放到了sys.path属性中。
2. 模块启动是把输入命令的目录（也就是当前路径），放到了sys.path属性中

考虑下面的目录结构：

```python
package/
    __init__.py
    mod1.py
package2/
    __init__.py
    run.py  
```

```python
# run.py 内容如下
import sys
from package import mod1
print(sys.path)
```

```python
➜  test_import_project git:(master) ✗ python package2/run.py
Traceback (most recent call last):
  File "package2/run.py", line 2, in <module>
    from package import mod1
ImportError: No module named package

# 以模块方式启动（成功）
➜  test_import_project git:(master) ✗ python -m package2.run
['',
'/usr/local/Cellar/python/2.7.11/Frameworks/Python.framework/Versions/2.7/lib/python27.zip',
...]
```

当需要启动的py文件引用了一个模块。你需要注意：在启动的时候需要考虑sys.path中有没有你import的模块的路径！
这个时候，到底是使用直接启动，还是以模块的启动？目的就是把import的那个模块的路径放到sys.path中。

## 考虑使用from … import

- 当只需要导入部分属性或方法时
- 模块中的这些属性和方法访问频率较高导致使用 "模块名.名称" 的形式进行访问过于繁琐时
- 模块的文档明确说明需要使用 `from ... import` 形式，导入的是一个包下面的子模块，且使用 `from ... import` 形式能够更为简单和便利时。如使用from io.drivers import zip 比 import io.drivers.zip 更好。

除了上述情况建议使用import,因为解决循环嵌套导入的一个方式就是使用import

# 优先使用 `absolute import` 来导入模块

在 Python2.4 以前默认为隐式的 `relative import`，局部范围的模块将覆盖同名的全局范围的模块。如果要使用标准库中同名的模块，需要深入考察 `sys.modules`。Python2.5 中后虽然默认的仍然是 `relative import`，但它为 `absolute import` 提供了一种新的机制，在模块中使用 `from __future__ import absolute_import` 语句进行说明后再进行导入。同时它还通过点号提供了一种显式进行 `relative import` 的方法，"." 表示当前目录， ".." 表示当前目录的上一层目录。

## 相对导入与绝对导入

Python 相对导入与绝对导入，<font color="red">这两个是针对于包内导入提出的概念</font>。包内导入即是包内的模块导入包内部的模块。(如一个包含__init__.py的包里有string.py, mod.py,在mod.py里import string, 这种情况如果不使用absolute导入那么最终导入的是我们写的string文件，而不是系统的包string).

绝对导入的格式为 `import A.B` 或 `from A import B`，相对导入格式为 `from . import B`或 `from ..A import B`，`.`代表当前模块，`..`代表上层模块，`...`代表上上层模块，依次类推。

相对导入可以避免硬编码带来的维护问题，例如我们改了某一顶层包的名，那么其子包所有的导入就都不能用了。但是 **存在相对导入语句的模块，不能直接运行**，否则会有异常

```python
ValueError: Attempted relative import in non-package
```

要运行包中包含绝对导入和相对导入的模块，可以用 `python -m A.B.C` 告诉解释器模块的层次结构。解释器会根据A.B.C和..B来推断出py文件所在的目录层次位置

### 导入模块时的一些规则：

在没有明确指定包结构的情况下，Python 是根据 `__name__` 来决定一个模块在包中的结构的，如果是 `__main__` 则它本身是顶层模块，没有包结构，如果是`A.B.C` 结构，那么顶层模块是 A。基本上遵循这样的原则：

- 如果是绝对导入，一个模块只能导入自身的子模块或和它的顶层模块同级别的模块及其子模块
- 如果是相对导入，一个模块必须有包结构且只能导入它的顶层模块内部的模块

如果一个模块被直接运行(非以模块方式运行)，则它自己为顶层模块，不存在层次结构，所以找不到其他的相对路径。

### py2和py3的区别

Python2.x 缺省为相对路径导入，Python3.x 缺省为绝对路径导入。绝对导入可以避免导入子包覆盖掉标准库模块（由于名字相同，发生冲突）。如果在 Python2.x 中要默认使用绝对导入，可以在文件开头加入如下语句:

```python
from __future__ import absolute_import
```

这句 import 并不是指将所有的导入视为绝对导入，而是指禁用 `implicit relative import`（隐式相对导入）, 但并不会禁掉 `explicit relative import`（显式相对导入）.

```
thing
├── books
│   ├── adventure.py
│   ├── history.py
│   ├── horror.py
│   ├── __init__.py
│   └── lovestory.py
├── furniture
│   ├── armchair.py
│   ├── bench.py
│   ├── __init__.py
│   ├── screen.py
│   └── stool.py
└── __init__.py
```

```
# stool.py
import bench                 # 此为 implicit relative import
from . import bench          # 此为 explicit relative import
from furniture import bench  # 此为 absolute import
```

隐式相对就是没有告诉解释器相对于谁，但默认相对与当前模块；而显示相对则明确告诉解释器相对于谁来导入。以上导入方式的第三种，才是官方推荐的，第一种是官方强烈不推荐的，**Python3 中已经被废弃**。

另外：**from __future__ import absolute_import: 在 3.0 以前的旧版本中启用相对导入等特性所必须的 future 语句**

## 实际开发

如果是写的应用程序，在加入了`from __future__ import absolute_import` 之后，那么在程序的编写过程中使用类似from package.submodule import b 只能导入系统环境路径里面的包，导入不了你写的应用程序的子包，如果导入你写的应用程序的子包必须使用from ..submodule import b。

如下面的例子，自己程序有urllib这个和第三方重名的包，我们发现导入的是系统的urllib包而不是我们自己写的目录.

![image-20190313151553901](../../../Library/Application%20Support/typora-user-images/image-20190313151553901.png)

写的是工具类程序，比如说写的是三方包，发布给别人安装。那么在加入了`from __future__ import absolute_import `之后还是可以在相对导入的时候使用from package.submodule import b 。那么这么做不是`from __future__ import absolute_import` 所说的特性没有了么。其实不然。因为我们编写的程序是需要安装在系统环境路径里面的，所以这种绝对导入的方式是可以相对导入的，这个时候搜索包名的时候是在系统环境路径里面搜索，但是因为你的包就在这些路径的某一个路径里面，所以可以搜得到from package.submodule import b 里面的b(模块,函数，变量，类)。这种编写工具包以绝对导入进行相对导入的方法还避免了from ..submodule import b 最好导入不超过两层的这一建议. 特别适合在开发大型工具的时候。

# 建议：i+=1 不等于 ++i

python中++i被解读成+(+i)

# 建议：使用with自动关闭资源

`with` 语句支持嵌套，支持多个 `with` 子句，它们两者可以相互转换。`with expr1 as e1, expr2 as e2` 与下面的嵌套形式等价：

```python
with expr1 as e1:
    with expr2 as e2:
```

## contextlib

自定义上下文管理器确实很方便，但是Python标准库还提供了更加易用的上下文管理器工具模块contextlib，它是通过生成器实现的，不需要再创建类以及__enter__和__exit__这两个特俗的方法.

```python
from contextlib import contextmanager

@contextmanager
def make_open_context(filename, mode):
    fp = open(filename, mode)
    try:
        yield fp
    finally:
        fp.close()

with make_open_context('/tmp/a.txt', 'a') as file_obj:
    file_obj.write("hello world")

```

yield关键词把<font color="red">上下文分割成两部分：yield之前就是__init__中的代码块；yield之后其实就是__exit__中的代码块</font>，yield生成的值会绑定到with语句as子句中的变量，例如在上面的例子中，yield生成的值是文件句柄对象fp，在下面的with语句中，会将fp和file_obj绑定到一起，也就是说file_obj此时就是一个文件句柄对象，那么它就可以操作文件了，因此就可以调用file_obj.write("hello world")

## 实际开发

将一个不是上下问管理器的类变成了一个上下文管理器，这样做的好处在于，我们就可以在执行真正的核心代码之前可以执行一部分代码，然后在执行完毕后，又可以执行一部分代码，这种场景在实际需求中还是很常见的。

```python
from contextlib import contextmanager

class DB:
    def query(self):
        print("query data")

@contextmanager
def make_myresource():
    print("connect to resource")
    yield MyResource()
    print("close to resource")

with DB() as r:
    r.query()
```

下面的示例充分体现上下文的含义：

```python
from flask_sqlalchemy import SQLAlchemy as _SQLAlchemy
from contextlib import contextmanager

class SQLAlchemy(_SQLAlchemy):
    @contextmanager
    def auto_commit(self):
        try:
            yield
            self.session.commit()
        except Exception as e:
            self.session.rollback()
            print(e)
```

# 使用else字句简化循环

在循环中，`else` 子句提供了隐含的对循环是否由 break 语句引发循环结束的判断(不需要借助标志位)。

当循环“自然”终结（循环条件为假）时 `else` 从句会被执行一次，而当循环是由 `break` 语句中断时，`else` 子句就不被执行。与 `for` 语句相似，`while` 语句中的 `else` 子句的语意是一样的：`else` 块在循环正常结束和循环条件不成立时被执行。

在 Python 的异常处理中，也提供了 `else` 子句语法，`try` 块没有抛出任何异常时，执行 `else` 块。Python 的异常处理中有一种 `try-except-else-finally` 形式。

# 遵循异常处理的几点基本原则

- 注意异常的粒度，不推荐在 `try` 中放入过多的代码。在处理异常的时候最好保持异常粒度的一致性和合理性。在 try 中放入过多的代码带来的问题是如果程序中抛出异常，将会较难定位，给 debug 和修复带来不便，因此应尽量只在可能抛出异常的语句块前面放入 try 语句。
- 谨慎使用单独的 except 语句处理所有异常，最好能定位具体的异常。同样也不推荐使用 `except Exception` 或者 `except StandardError` 来捕获异常。如果必须使用，最好能够使用 raise 语句将异常抛出向上层传递。
- 注意异常捕获的顺序，在合适的层次处理异常。Python 中内建异常以类的形式出现，Python 2.5 后异常被迁移到新式类上，启用了一个新的所有异常之母的 
- 使用更为友好的异常信息，遵守异常参数的规范。软件最终是位用户服务的，当异常发生的时候，异常信息清晰友好与否直接关系到用户体验。通常来说有两类异常阅读者：使用软件的人和开发软件的人。

# 建议：避免 finally 中可能发生的陷阱

无论 `try` 语句中是否有异常抛出，`finally` 语句总会被执行。由于这个特性，`finally` 语句经常被用来做一些清理工作。

但使用 finally 时，也要特别小心一些陷阱。

- 当 `try` 块中发生异常的时候，如果在 `except` 语句中找不到对应的异常处理，异常将会被临时保存起来，当 `finally` 执行完毕的时候，临时保存的异常将会再次被抛出，但如果 `finally` 语句中产生了新的异常或者执行了 `return` 或者 `break` 语句，那么临时保存的异常将会被丢失，从而导致异常屏蔽。
- 在实际应用程序开发过程中，并不推荐在 `finally` 中使用 `return` 语句进行返回，这种处理方式不仅会带来误解而且可能会引起非常严重的错误。

finally的另外一个陷阱(在return a之前会先执行finnally)：

```python
def return_test(a):
    try:
        if a < 0:
            raise ValueError("值必须大于0")
        else:
            print("else")
            return a
    except ValueError as e:
        print(e)
    finally:
        print("The end")
        return -1

res = return_test(2)
# res = -1
print(res)

```

# 连接字符串优先还有join而不是+

```python
import timeit
# 生成测试所需要的字符数组
strlist = ["it is a long value string will not keep in memory" for n in range(100000)]
def join_test():
    return "".join(strlist) # 使用 join 方法连接 strlist 中的元素并返回字符串
def plus_test():
    result = ""
    for i, v in enumerate(strlist):
        return += v
	return result

if __name__ == "__main__":
    join_timer = timeit.Timer("join_test()", "from __main__ import join_test")
    print(join_timer.timeit(number=100))
    plus_timer = timeit.Timer("plus_test()", "from __main__ import plus_test")
    print(plus_timer.timeit(number=100))

```

# `[]`、`()` 和 `{}`：一致的容器初始化形式

推荐在需要生成列表的时候使用列表解析：

- 使用列表解析更为直观清晰，代码更为简洁

- 列表解析的效率更高（对于大数据处理，列表解析并不是一个最佳选择，过多的内存消耗可能会导致 `MemoryError`）

# 警惕默认参数潜在的问题

def 在 Python 中是一个可执行的语句，当解释器执行 def 的时候，默认参数也会被计算，并存在函数的 `.func_defaults` 属性中。由于 Python 中函数参数传递的是对象，可变对象在调用者和被调用者之间共享，而再次调用的时候默认参数不会重新计算。

如果不想让默认参数所指向的对象在所有的函数调用中被共享，而是在函数调用的过程中动态生成，可以在定义的时候用 None 对象作为占位符。

```python
def appendtest(newitem, lista=[]):  # 默认参数是空列表
    print(id(lista))
    lista.append(newitem)
    print(id(lista))
    return lista
```

# 慎用变长参数

慎用可变长度参数，原因如下：

- 使用过于灵活，在混合普通参数或者默认参数的情况下，变长参数意味着这个函数的签名不够清晰，存在多种调用方式。另外变长参数可能会破坏程序的健壮性。
- 如果一个函数的参数列表很长，虽然可以通过使用 `*args` 和 `**kwargs` 来简化函数的定义，但这通常意味着这个函数可以有更好的实现方式，应该被重构。
- 可变长参数适合在下列情况下使用：
  - 为函数添加一个装饰器
  - 如果参数的数目不确定，可以考虑使用变长参数。
  - 用来实现函数的多态或者在继承情况下子类需要调用父类的某些方法的时候

# 深入理解 `str()` 和 `repr()` 的区别

- 两者之间的目标不同：`str()` 主要面向用户，其目的是可读性，返回形式为用户友好性和可读性都较强的字符串类型；而 `repr()` 面向的是 Python 解释器，或者说开发人员，其目的是准确性，其返回值表示 Python 解释器内部的含义，常作为编程人员 debug 用途
- 在解释器中直接输入时默认调用 `repr()` 函数，而 print 则调用 `str()` 函数
- `repr()` 的返回值一般可以用 `eval()` 函数来还原对象，通常来说有如下等式：`obj == eval(repr(obj))`，这个等式不是所有情况下都成立
- 一般来说在类中都应该定义 `__repr__()` 方法，而 `__str__()` 方法则为可选，当可读性比准确性更为重要的时候应该考虑定义 `__str__()` 方法。如果类中没有定义 `__str__()` 方法，则默认会使用 `__repr__()` 方法的结果来返回对象的字符串表示形式。用户实现 `__repr__()` 方法的时候最好保证其返回值可以用 `eval()` 方法使对象重新还原。

# 分清 staticmethod 和 classmethod 的适用场景

classmethod 适用于类的继承的某些情况，如对类属性的修改，继承的类对各自类属性的修改，这时的某些set方法可以用classmethod.如初始化成不同对象，也可以使用classmethod.

方法既不跟特定的实例相关也不跟特定的类相关，因此将其定义为静态方法是个不错的选择，这样代码能够一目了然。静态方法定义在类中，较之外部函数，能够更加有效地将代码组织起来，从而使相关代码的垂直距离更近，提高代码的可维护性。



# 利用状态模式优化代码

### 什么是状态模式

当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了类本身。

### 应用场景

当控制一个对象的状态转换的条件表达式过于复杂时,把状态的判断逻辑转移到表示不同状态的一系列类当中,可以把复杂的判断逻辑简化。(当一个对象的行为取决于它的状态,并且它必须在运行时刻根据状态改变他的行为)。

```python
from termcolor import colored
from state import curr, switch, stateful, State, behavior

@stateful
class User(object):
    def __init__(self, name):
        self.name = name

    class NeedSignin(State):
        default = True
        @behavior
        def signin(self):
            print(colored("{} login success...".format(self.name), "green"))
            switch(self, self.__class__.Signin)

    class Signin(State):
        @behavior
        def logout(self):
            print(colored("{} logout success...".format(self.name), "blue"))

        @behavior
        def payment(self):
            print(colored("{} payment success...".format(self.name), "red"))

user = User("jack")
print(curr(user))
user.signin()
user.logout()
user.payment()
print(curr(user))
```

使用状态模式的好处：

- 可以减少if-else，也可以减少在一个方法上多个装饰器的帽子
- 把一个巨类变得更清晰
- 当调用当前状态不存在的行为时，出错信息是AttributeError错误，可以更精确地定位错误。

对state模块的几点说明：

1. `@stateful`重载了被修饰类的`__getattr__`使得能调用当前状态类的方法
2. 状态类继承`State`, 可以重写`__begin__`和`__end__`, 状态类可以自定义进入和离开当前状态对宿主的初始化和清理操作。
3. 默认状态通过`default = True`来设置。

## 观察者模式

每个设计模式都是围绕如下三个问题：

1. 为什么？即为什么要使用这个设计模式，在使用这个模式之前存在什么样的问题？
2. 是什么？通过Python语言来去实现这个设计模式，用于解决为什么中提到的问题。
3. 怎么用？理解了为什么我们也就基本了解了什么情况下使用这个模式，不过在这里还是会细化使用场景，阐述模式的局限和优缺点。

### 耦合和解耦

我们常常说模块之间要“解耦合”，软件设计要“松耦合”。那么什么是“耦合”呢？

实际上耦合是指两个模块之间（模块可以理解为两坨代码，所以可以是函数，可以是类，或者更大范围的系统）发生了关系，比如一个模块调用了另一个模块的函数，或者一个模块需要获取另一个模块的数据，总之有了联系就有了耦合。所谓“解耦合”或者“松耦合”是说让两个模块之间的联系没有那么紧密，这样一个模块的变化不会影响另一个模块的代码。那么我们如何来使我们的系统是一个“松耦合”的系统呢？

实现“松耦合”最重要的就是**抽象**和**一致性**，白话就是要通过抽象的接口（Python中没有接口的概念，可以理解为抽象的类）来联系调用方和被调方。

```python
class A(object):
    def __init__(self):
        self.obj = B(param1, param2)

    def method_of_a(self):
        self.obj.method_of_b(param3)


class B(object):
    def __init__(self, param1, param2):
        ...

    def method_of_b(self, param3):
         # do something
```

但是这种情况下，如果B发生改变，或者想换成另一个类C，这时就需要更改A的代码，那么如果我们把A和B之间的联系抽象出来，通过接口（或者类似接口的东西）来连接A和B我们就可以某种程度上屏蔽这种变化.

```python
class A(object):
    def __init__(self, some_obj):
        self.obj = some_obj

    def method_of_a(self):
        self.obj.consistent_method(param3)

class B(object):
    def __init__(self, param1, param2):
        ...
    def consistent_method(self, param3):
        ...

class C(object):
    def __init__(self, param1, param2):
        ...
    def consistent_method(self, param3):
        ...
```

在这个例子中，我们的参数some_obj可以想象成一个抽象类或者Java中的接口，我们传递参数时可以传递具体实现类的对象（比如B或者C的对象），但在这里只是一个**抽象**。

另外，我们的B和C都实现了consistent_method，这就是**一致性**的体现.

### 为什么

假设我们设计了某种功能，当用户点击页面上的按钮时，我们需要为用户做两件事，一是做页面变换显示出预期的效果，二是响起特定的音乐。那么我们的代码可能是这样的：

```
def onClick():
    changePage()
    playMusic()
```

后来你的需求有变动，还需要记录用户点击时间，需要弹出提示信息，需要......
 于是你需要不断的修改上述的代码，可能是这样的

```
def onClick():
    changePage()
    playMusic()
    recordTime()
    popupHint()
    ...
```

我们认为onClick()和这些功能函数耦合的过于紧密了，每次的改动都会影响onClick函数。<font color="red">这类问题抽象出来就是当一个事件发生时需要调用很多功能模块，而解决这类问题最好的方式就是观察者模式，也叫发布-订阅模式。</font>

### 是什么

观察者模式是说你有一个观察者列表，这个列表中的函数或者某种功能都在观察某个事件的发生，一旦发生，这些函数或者功能就会自动执行，这个其实很好理解。

```python
class Button(object):
    """publisher or subject"""
    def __init__(self):
        self.observer_list = []

    def register(self, func):
        self.observer_list.append(func)

    def unregister(self, func):
        self.observer_list.remove(func)

    def onClick():
        for func in self.observer_list:
            func()
    ...

def playMusic():
     """subscriber or observer"""
    ...

def changePage():
    """subscriber or observer"""
    ...
...

def main():
    button = Button()
    button.register(playMusic)
    button.register(changePage)
```

通过这种方式，我们实现了发布者和订阅者之间的松耦合，它们之间并不直接联系，而是通过<font color="red">统一的register/unregister(类似于统一的抽象接口)</font>来绑定和解绑定。

### 怎么用

似乎代码也没少啊，而且注册的时候不还是要修改代码去注册新的功能吗？这里基于以下几种好处我们要使用这个模式：

- 使用这个模式的最大好处之一就是**灵活**
  我们可以动态的修改监听的事件，比如用户不想在点击该按钮的时候响起音乐，那么当ta不选择这一项时，我们的程序可以灵活的通过unregister来解绑定，试想如果你不使用观察者模式，是很难解绑定的，你就需要去修改原来的一堆代码，显然这不现实。有了unregister可以在那堆代码外面进行影响那堆代码运行的操作。所以，使用这个模式的理由之一就是你需要动态的绑定和解绑相应的功能时，你就需要观察者模式。
- 第二个好处是代码复用
  比如你有很多个按钮，都需要统一的注册某些功能，这个时候你就可以实现一个父类，在初始化的时候将所有的需要注册的功能都注册好，子类直接继承就好了，子类当然还可以注册自己特殊功能。

## 利用发布订阅模式进行解耦

最简单的发布订阅：

```python
# Broker.py
from collections import defaultdict
route_table = defaultdict(list)
def sub(topic, callback):
    if callback in route_table[topic]:
        return
    route_table[topic].append(callback)

def pub(topic, *args, **kw):
    for func in route_table[topic]:
        func(*args, **kw)
```

```python
import Broker
def greeting(name):
    print('Hello, {}'.format(name))
Broker.sub('greet', greeting)
Broker.pub('greet', 'LaiYonghao')
```

python的blinker 和 message 两个模块可以实现发布订阅模式。

发布订阅模式中发布者和订阅者对系统拓扑没有感知，关注的是订阅和发布的主题。

### 利用message解决的一个问题

假设你写了一个库,  里面有一个重要的函数bar

```python
def bar():
    print "this is bar"
    do_some_thing()
```

别人在使用你这个库的时候，使用的logging模块记录日志，对于脚本的调用`python test.py > /dev/null`, 因为这样标准输出print的结果就石沉大海了。那怎么办，我这边的print要改成logging吗？关键是有的人在使用你的库的时候不用logging模块，就用print.那怎么修改？需要库和应用方联合使用一起来修改。

使用message来修改bar函数，应用方要使用logging模块还有就用标准输出也好，完全由应用方来定。

```python
# client.py
import message

LOG_MSG = ("log", "foo")

def bar():
    # 这边的使用元组作为topic，保证可hash
    message.pub(LOG_MSG, "haha, Calling bar")
    do_some_thing()
```

不同的调用方：

标准输出

```python
import message
import client

def handle_foo_log_msg(txt):
    print txt

message.sub(client.LOG_MSG, handle_foo_log_msg)

client.bar()
```

logging日志

```python
import message
import client

def handle_foo_log_msg(txt):
    import logging
    logging.critical(txt)

message.sub(client.LOG_MSG, handle_foo_log_msg)

client.bar()
```

## 掌握字符串的基本用法

### 多行的字符串常量

```python
In [4]: s = ('select * '
   ...: 'from stu')

In [5]: s
Out[5]: 'select * from stu'
```

利用 `()` 和 单引号做字符串拼接和 用三引号的不同：

```python
In [6]: s = """select * from
   ...: stu"""

In [7]: s
Out[7]: 'select * from\nstu'
```

### py2判断是不是字符串

`isinstance(s, basestring)`

py3中basestring被废弃了。

### 判断字符串是否包含子串

使用`in` 和 `not in`， 不使用find和index(index找不到会报错，find找不到返回-1)

### split和partition

#### split

```python
In [14]: "hello    world  ".split()
Out[14]: ['hello', 'world']

In [15]: "hello    world  ".split("")
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-15-7998eb369a7f> in <module>()
----> 1 "hello    world  ".split("")

ValueError: empty separator

In [16]: "hello    world  ".split(" ")
Out[16]: ['hello', '', '', '', 'world', '', '']
```

split参数为空的情况：会先去除字符串左右两边的空行，然后以任意长度的空白串进行分割。

split() 不能参数不能是空字符串，当时一个字符串的时候，会认为连续两个sep之间有一个空串。

## 按需选择sort和sorted

`sorted(iterable, /, *, key=None, reverse=False)`

```
Help on method_descriptor:

sort(...)
    L.sort(key=None, reverse=False) -> None -- stable sort *IN PLACE*
```

key是一个带参数的函数，用来为每个元素提取比较值，默认为None(即直接比较每个元素)。

sorted可以作用于任意可迭代对象，sort一般只用于列表，针对元组使用sort会抛出异常。sorted的功能强大，可以支持多种排序：

对字典进行排序

```python
In [26]: sorted(dic.items(), key=itemgetter(1))
Out[26]: [('egon', 34), ('alex', 130), ('jack', 230)]

In [27]: dict(sorted(dic.items(), key=itemgetter(1)))
Out[27]: {'egon': 34, 'alex': 130, 'jack': 230}
```

多维list排序

先根据等级再根据分数进行排序。

```python
In [28]: gameresult = [["Bob", 97, "A"], ["Jack", 97, "B"], ["Alex", 67, "C"]]

In [29]: sorted(gameresult, key=itemgetter(2,1))
Out[29]: [['Bob', 97, 'A'], ['Jack', 97, 'B'], ['Alex', 67, 'C']]
```

字典中混合list排序

```python
In [43]: mydict
Out[43]:
{'Li': ['M', 7],
 'Zhang': ['E', 2],
 'Wang': ['P', 3],
 'Du': ['C', 2],
 'Ma': ['C', 9],
 'Zhe': ['H', 7]}

In [44]: sorted(mydict.items(), key=lambda x: itemgetter(1)(x[1]))
Out[44]:
[('Zhang', ['E', 2]),
 ('Du', ['C', 2]),
 ('Wang', ['P', 3]),
 ('Li', ['M', 7]),
 ('Zhe', ['H', 7]),
 ('Ma', ['C', 9])]
```

list混合字典

```python
In [45]: gameresult = [{"name": "Bob", "wins": 5, "losses": 2}, {"name": "Alex", "wins": 10, "losses":1}]

In [46]: sorted(gameresult, key=itemgetter('wins', 'losses'))
Out[46]:
[{'name': 'Bob', 'wins': 5, 'losses': 2},
 {'name': 'Alex', 'wins': 10, 'losses': 1}]
```

普通函数可能只比较一个，用了itemgetter可以比较两个。

## 使用counter进行计数统计

```
In [49]: c = Counter('abcdeabcdabcaba')

In [50]: c
Out[50]: Counter({'a': 5, 'b': 4, 'c': 3, 'd': 2, 'e': 1})

In [51]: c.keys()
Out[51]: dict_keys(['a', 'b', 'c', 'd', 'e'])

In [52]: c.values()
Out[52]: dict_values([5, 4, 3, 2, 1])

In [53]: c.most_common(3)
Out[53]: [('a', 5), ('b', 4), ('c', 3)]
```

<font color="red">Counter继承自字典, 所以得到的是字典类型。除了update，也有substract(), 值允许为0或负数。</font>

## 配置文件使用ConfigParser

configparser支持conf的下面写法：

```
# format.conf
[DEFAULT]
conn_str = %(dbn)%s://%(user)s:%(pw)s@%(host)s:%(port)s/%(db)s
dbn = mysql
user = root
host = localhost
port = 3306
[db1]
user = aaa
pw = ppp
db = example
```

```
import ConfigParser
conf = ConfigParser.ConfigParser()
conf.read("format.conf")
conf.get("db1", "conn_str")
```

## 