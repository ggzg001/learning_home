## 对象的字符串显示

```python
class Pair:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __repr__(self):
        return "Pair({0.x!r},{0.y!r})".format(self)
    
    def __str__(self):
        return "{0.x!s}, {0.y!s}".format(self)
```

`__repr__()` 生成的文本字符串标准做法是需要让 `eval(repr(x)) == x` 为真。 如果实在不能这样子做，应该创建一个有用的文本表示，并使用 < 和 > 括起来。比如:

```
>>> f = open('file.dat')
>>> f
<_io.TextIOWrapper name='file.dat' mode='r' encoding='UTF-8'>
```

`__repr__ `可以替代`__str__`

## 让对象支持上下文管理协议



```
from socket import socket, AF_INET, SOCK_STREAM

class LazyConnection:
    def __init__(self, address, family=AF_INET, type=SOCK_STREAM):
        self.address = address
        self.family = family
        self.type = type
        self.sock = None

    def __enter__(self):
        if self.sock is not None:
            raise RuntimeError('Already connected')
        self.sock = socket(self.family, self.type)
        self.sock.connect(self.address)
        return self.sock

    def __exit__(self, exc_ty, exc_val, tb):
        self.sock.close()
        self.sock = None
```

这个类的关键特点在于它表示了一个网络连接，但是初始化的时候并不会做任何事情(比如它并没有建立一个连接)。 连接的建立和关闭是使用 `with` 语句自动完成的.

不管 `with` 代码块中发生什么，上面的控制流都会执行完，就算代码块中发生了异常也是一样的。 事实上，`__exit__()` 方法的第三个参数包含了异常类型、异常值和追溯信息(如果有的话)。`__exit__()` 方法能自己决定怎样利用这个异常信息，或者忽略它并返回一个None值。 如果 `__exit__()` 返回 `True` ，那么异常会被清空，就好像什么都没发生一样， `with` 语句后面的程序继续在正常执行.

还有一个技巧需要注意：

```
from functools import partial

conn = LazyConnection(('www.python.org', 80))
# Connection closed
with conn as s:
    # conn.__enter__() executes: connection open
    s.send(b'GET /index.html HTTP/1.0\r\n')
    s.send(b'Host: www.python.org\r\n')
    s.send(b'\r\n')
    resp = b''.join(iter(partial(s.recv, 8192), b''))
```

<font color="red">resp = b''.join(iter(partial(s.recv, 8192), b''))</font>

## 使用`__slots__`来节省内存

​	_slots__是一个类变量,变量值可以是列表,元祖,或者可迭代对象,也可以是一个字符串(意味着所有实例只有一个数据属性).

​	有了_slots_ 之后，实例就不再有`__dict__`属性了

​	另外，slots可以对实例属性进行约束，虽然初衷不是这样的

​	实例通过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典，这跟元组或列表很类似。 在 `__slots__`中列出的属性名在内部被映射到这个数组的指定小标上。

​	尽管slots看上去是一个很有用的特性，很多时候你还是得减少对它的使用冲动。 Python的很多特性都依赖于普通的基于字典的实现。 另外，定义了slots后的类不再支持一些普通类特性了，比如多继承。 大多数情况下，你应该只在那些经常被使用到的用作数据结构的类上定义slots (比如在程序中需要创建某个类的几百万个实例对象)。

如果类变量与slots中的变量同名，则该变量被设置为readonly.

```
from memory_profiler import profile

class People:
    def __init__(self, age):
        self.age = age

@profile
def main():
    [People(i) for i in range(100000)]

class NewPeople:
    __slots__ = 'age'
    def __init__(self, age):
        self.age = age

@profile
def main2():
    [NewPeople(i) for i in range(100000)]

if __name__ == '__main__':
    main()
    main2()
```

所以，在确定了类的属性固定的情况下，可以使用__slots__来优化内存

## 使用下划线在类中封装属性名

使用下划线开头的约定同样适用于模块名和模块级别函数。 例如，如果你看到某个模块名以单下划线开头(比如_socket)，那它就是内部实现。 类似的，模块级别函数比如 `sys._getframe()` 在使用的时候就得加倍小心了。

使用双下划线开始会导致访问名称变成其他形式. 使用双下划线定义的属性通过继承是无法被覆盖的。

<font color="red">大多数而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类， 并且有些内部属性应该在子类中隐藏起来，那么才考虑使用双下划线方案。</font>

## 创建可管理或动态的实例属性

<font color="red">想给某个实例attribute增加除访问与修改之外的其他处理逻辑，比如类型检查或合法性验证。</font>

最简单解决方案：使用property

```
class Person(object):
    def __init__(self, name):
        self.name = name

    @property
    def name(self):
        return self._name
    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError("name必须是字符串")
        self._name = value
    @name.deleter
    def name(self):
        del self._name
```

一个property属性其实就是一系列相关绑定方法的集合。如果你去查看拥有property的类， 就会发现property本身的fget、fset和fdel属性就是类里面的普通方法。

```
In [79]: Person.name.fget
Out[79]: <function __main__.Person.name(self)>

In [80]: Person.name.fset
Out[80]: <function __main__.Person.name(self, value)>

In [81]: Person.name.setter
Out[81]: <function property.setter>
```

场景：

1. 只有当你确实需要对attribute执行其他额外的操作的时候才应该使用到property。
2. Properties还是一种定义动态计算attribute的方法。 这种类型的attributes并不会被实际的存储，而是在需要的时候计算出来。我们通过使用properties，将所有的访问接口形式统一起来， 对半径、直径、周长和面积的访问都是通过属性访问，就跟访问简单的attribute是一样的。 如果不这样做的话，那么就要在代码中混合使用简单属性访问和方法调用。

## 面向对象之super

`super()` 有个令人吃惊的地方是它并不一定去查找某个类在MRO中下一个直接父类， 你甚至可以在一个没有直接父类的类中使用它。例如，考虑如下这个类:

```
class A:
    def spam(self):
        print('A.spam')
        super().spam()
```

如果你试着直接使用这个类就会出错：

```
>>> a = A()
>>> a.spam()
A.spam
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "<stdin>", line 4, in spam
AttributeError: 'super' object has no attribute 'spam'
>>>
```

```
class A:
    def __init__(self):
        print("A")
        super().__init__()

class B:
    def __init__(self):
        print("B")

class C(A, B):
    pass

C()
print(C.mro())
```

当你使用 `super()` 函数时，Python会在MRO列表上继续搜索下一个类。 只要每个重定义的方法统一使用 `super()` 并只调用它一次， 那么<font color="red">控制流</font>最终会遍历完整个MRO列表，每个方法也只会被调用一次。

程序启动，一次运行，在mro列表流动，因为是一次程序的运行，所以流动到哪是知道的，下一次从哪继续流也是可知的。

然而，由于 `super()` 可能会调用不是你想要的方法，你应该遵循一些通用原则。 

* 确保在继承体系中所有相同名字的方法拥有可兼容的参数签名(比如相同的参数个数和参数名称)。 这样可以确保 `super()` 调用一个非直接父类方法时不会出错。 
* 最好确保最顶层的类提供了这个方法的实现，这样的话在MRO上面的查找链肯定可以找到某个确定的方法。

## 子类中扩展property

```
class Person:
    def __init__(self, name):
        self.name = name

    # Getter function
    @property
    def name(self):
        return self._name

    # Setter function
    @name.setter
    def name(self, value):
        if not isinstance(value, str):
            raise TypeError('Expected a string')
        self._name = value

    # Deleter function
    @name.deleter
    def name(self):
        raise AttributeError("Can't delete attribute")

class SubPerson(Person):
    @property
    def name(self):
        print('Getting name')
        return super().name

    @name.setter
    def name(self, value):
        print('Setting name to', value)
        super(SubPerson, SubPerson).name.__set__(self, value)

    @name.deleter
    def name(self):
        print('Deleting name')
        super(SubPerson, SubPerson).name.__delete__(self)
```

注意的点：

`super(SubPerson, SubPerson).name` 不能写成`super().name`, 前者是一个property，后者则是一个字符串类型. 这里的super里的参数是类，为什么是类其实可以参考描述符是类属性来简单理解。

如果你仅仅只想扩展property的某一个方法，那么可以像下面这样写(不能仅仅简单地写`@name.setter`, 这样会报错)：

```
class SubPerson(Person):
    @Person.name.getter
    def name(self):
        print('Getting name')
        return super().name
```

在这个特别的解决方案中，我们没办法使用更加通用的方式去替换硬编码的 `Person` 类名。 如果你不知道到底是哪个基类定义了property， 那你只能通过重新定义所有property并使用 `super()` 来将控制权传递给前面的实现。

## 创建一个全新的实例属性

如果你想创建一个全新的实例属性，这个实例属性有一些特别的定制操作，可以通过一个描述器类的形式来定义它的功能。

最后要指出的一点是，<font color="red">如果你只是想简单的自定义某个类的单个属性访问的话就不用去写描述器了</font>。 这种情况下使用property技术会更加容易。 当程序中有很多重复代码的时候描述器就很有用了。

```python
class Type(object):
    def __init__(self, name, typed_value):
        self.name = name
        self.typed_value = typed_value

    def __set__(self, instance, value):
        if not isinstance(value, self.typed_value):
            raise TypeError(f"expect type {self.typed_value}")
        instance.__dict__[self.name] = value

    def __get__(self, instance, cls):
        if not instance:
            return self
        return instance.__dict__[self.name]

    def __delete__(self, instance):
        del instance.__dict__[self.name]

def typeassert(**kwargs):
    def outer(cls):
        for name, expected_type in kwargs.items():
            setattr(cls, name, Type(name, expected_type))
        return cls
    return outer

@typeassert(name=str, age=int)
class People:
    def __init__(self, name, age):
        self.name = name
        self.age = age
```

## 利用非属性描述符进行延迟计算

场景： 对于实例的属性，只在访问的时候才会计算结果。 但是一旦被访问后，你希望结果值被缓存起来，不用每次都去计算。

解决办法：定义一个延迟属性的一种高效方法是通过使用一个描述器类

```python
class Lazycache:
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, cls):
        if not instance:
            return None
        value = self.func(instance)
        setattr(instance, self.func.__name__, value)
        retrun value

import math

class Circle:
    def __init__(self, radius):
        self.radius = radius

    @Lazycache
    def area(self):
        print('Computing area')
        return math.pi * self.radius ** 2
```

上述实现方式仍然可以修改实例的属性值，可以通过内置的property来组织属性的设置值：

```python
def lazyproperty(func):
    name = '_lazy_' + func.__name__
    @property
    def lazy(self):
        if hasattr(self, name):
            return getattr(self, name)
        else:
            value = func(self)
            setattr(self, name, value)
            return value
    return lazy

import math

class Circle:
    def __init__(self, radius):
        self.radius = radius
    # 用内置的property来帮忙定制自己的lazyproperty
    # area = lazyproperty(area)
    @lazyproperty
    def area(self):
        print('Computing area')
        return math.pi * self.radius ** 2

c = Circle(10)
print(c.area)
c.area = 20
```

low的方式：

```python
import math


class lazyproperty(object):
    def __init__(self, func):
        self.func = func
        self.value = None

    def __get__(self, instance, cls):
        if not instance:
            return self
        if not self.value:
            self.value = self.func(instance)
        return self.value


class Circle:
    def __init__(self, radius):
        self.radius = radius

    # area = lazyproperty(area)
    @lazyproperty
    def area(self):
        print('Computing area')
        return math.pi * self.radius ** 2

    @lazyproperty
    def perimeter(self):
        print('Computing perimeter')
        return 2 * math.pi * self.radius
```

## 简化数据结构的初始化

```python
class Structure:
    _field = []
    def __init__(self, *args, **kwargs):
        if len(args) > len(self._field):
            raise TypeError('Expected {} arguments'.format(len(self._fields)))

        for k, v in zip(self._field, args):
            setattr(self, k, v)

        for name in self._field[len(args):]:
            setattr(self, name, kwargs.pop(name))

        if kwargs:
            raise TypeError('Invalid argument(s): {}'.format(','.join(kwargs)))
```

```python
class Structure3:
    # Class variable that specifies expected fields
    _fields = []

    def __init__(self, *args, **kwargs):
        if len(args) > len(self._fields):
            raise TypeError('Expected {} arguments'.format(len(self._fields)))

        # Set the arguments
        for index, value in enumerate(args):
            setattr(self, self._fields[index], value)

        # Set the additional arguments (if any)
        for name in self._fields[len(args):]:
            setattr(self, name, kwargs.pop(name))

        if kwargs:
            raise TypeError('Duplicate values for {}'.format(','.join(kwargs)))

# Example use
if __name__ == '__main__':
    class Stock(Structure3):
        _fields = ['name', 'shares', 'price']
    s1 = Stock('ACME', 50, 91.1)
    s2 = Stock('ACME', 50, price=91.1)
    print(vars(s1), vars(s2))
```

有一个用法：

```
In [83]: dic = {"a":1, "b":2}

In [84]: dic.keys()
Out[84]: dict_keys(['a', 'b'])

In [85]: dic.keys() - ['a']
Out[85]: {'b'}
```

## 定义接口或者抽象基类

抽象基类的一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口

```
def serialize(obj, stream):
    if not isinstance(stream, IStream):
        raise TypeError('Expected an IStream')
    pass
```

`@abstractmethod` 还能注解静态方法、类方法和 `properties` 。 你只需保证这个注解紧靠在函数定义前即可：

```
class A(metaclass=ABCMeta):
    @property
    @abstractmethod
    def name(self):
        pass

    @name.setter
    @abstractmethod
    def name(self, value):
        pass

    @classmethod
    @abstractmethod
    def method1(cls):
        pass

    @staticmethod
    @abstractmethod
    def method2():
        pass
```

## 定义基类去实现某些方法

标准库中有很多用到抽象基类的地方。`collections` 模块定义了很多跟容器和迭代器(序列、映射、集合等)有关的抽象基类。`io` 库定义了很多跟I/O操作相关的基类。

你可以使用预定义的抽象类来执行更通用的类型检查，例如：

```
import collections

# Check if x is a sequence
if isinstance(x, collections.Sequence):
...

# Check if x is iterable
if isinstance(x, collections.Iterable):
...

# Check if x has a size
if isinstance(x, collections.Sized):
...

# Check if x is a mapping
if isinstance(x, collections.Mapping):
```

## 实现自定义容器

你想实现一个自定义的类来模拟内置的容器类功能，比如列表和字典。但是你不确定到底要实现哪些方法。

`collections` 定义了很多抽象基类，当你想自定义容器类的时候它们会非常有用。 比如你想让你的类支持迭代，那就让你的类继承 `collections.Iterable` 即可。

不过你需要实现 `collections.Iterable` 所有的抽象方法。你可以先试着去实例化一个对象，在错误提示中可以找到需要实现哪些方法.

```
In [1]: import collections

In [2]: collections.Iterable()
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
<ipython-input-2-8f1024fc7985> in <module>()
----> 1 collections.Iterable()

TypeError: Can't instantiate abstract class Iterable with abstract methods __iter__
```

使用 `collections` 中的抽象基类可以确保你自定义的容器实现了所有必要的方法。并且还能简化类型检查。 你的自定义容器会满足大部分类型检查需要。

collections 中很多抽象类会为一些常见容器操作提供默认的实现， 这样一来你只需要实现那些你最感兴趣的方法即可。假设你的类继承自 collections.MutableSequence。

```
import collections

class Items(collections.MutableSequence):
    def __init__(self, initial=None):
        self._items = list(initial) if initial else []

    def __getitem__(self, index):
        print('Getting:', index)
        return self._items[index]

    def __setitem__(self, index, value):
        print('Setting:', index, value)
        self._items[index] = value

    def __delitem__(self, index):
        print('Deleting:', index)
        del self._items[index]

    def __len__(self):
        return len(self._items)

    def insert(self, index, value):
        print('Inserting:', index, value)
        self._items.insert(index, value)
```

如果你创建 `Items` 的实例，你会发现它支持几乎所有的核心列表方法(如append()、remove()、count()等)。

## 实现数据模型的类型约束

```python
# 基础构件
class Descriptor(object):
    def __init__(self, name=None, **kwargs):
        self.name = name
        for key,  value in kwargs.items():
            setattr(self, key, value)

    def __set__(self, instance, value):
        # 下面这句相当于instance.xx = value,数据描述符还是会调用__set__ 方法造成递归
        # setattr(instance, self.name, value)
        instance.__dict__[self.name] = value

class Typed(Descriptor):
    expected_type = type(None)

    def __set__(self, instance, value):
        if not isinstance(value, self.expected_type):
            raise TypeError(f"expect type {self.expected_type}")

        super().__set__(instance, value)

class Unsigned(Descriptor):
    def __set__(self, instance, value):
        if value < 0:
            raise ValueError("expect value > 0")
        super().__set__(instance, value)

class MaxSized(Descriptor):
    def __init__(self, name=None, **kwargs):
        if "size" not in kwargs:
            raise TypeError("missing key size")
        super().__init__(name, **kwargs)

    def __set__(self, instance, value):
        if len(value) > self.size:
            raise ValueError('size must be < ' + str(self.size))
        super().__set__(instance, value)

# 组合构件
class Int(Typed):
    expected_type = int

class Float(Typed):
    expected_type = float

class String(Typed):
    expected_type = str

class UnsignedInt(Int, Unsigned):
    pass

class UnsignedFloat(Float, Unsigned):
    pass

class SizedString(String, MaxSized):
    pass

# 使用
class Stock:
    name = SizedString("name", size=4)
    price = UnsignedFloat("price")

    def __init__(self, name, price):
        self.name = name
        self.price = price
```

也可以使用装饰器的方式来装饰类

```python
def check_attributes(**kwargs):
    def inner(cls):
        for key, value in kwargs.items():
            if isinstance(value, Descriptor):
                setattr(value, "name", key)
            else:
                value = value(key)
            setattr(cls, key, value)
        return cls
    return inner

# 使用
@check_attributes(name=SizedString(size=4), price=UnsignedFloat)
class Stock:
    name = SizedString("name", size=4)
    price = UnsignedFloat("price")

    def __init__(self, name, price):
        self.name = name
        self.price = price
```

### 使用装饰器替代前面的混入方式

```python
# Decorator for applying type checking
def Typed(expected_type, cls=None):
    if cls is None:
        return lambda cls: Typed(expected_type, cls)
    super_set = cls.__set__

    def __set__(self, instance, value):
        if not isinstance(value, expected_type):
            raise TypeError('expected ' + str(expected_type))
        super_set(self, instance, value)

    cls.__set__ = __set__
    return cls


# Decorator for unsigned values
def Unsigned(cls):
    super_set = cls.__set__

    def __set__(self, instance, value):
        if value < 0:
            raise ValueError('Expected >= 0')
        super_set(self, instance, value)

    cls.__set__ = __set__
    return cls


# Decorator for allowing sized values
def MaxSized(cls):
    super_init = cls.__init__

    def __init__(self, name=None, **opts):
        if 'size' not in opts:
            raise TypeError('missing size option')
        super_init(self, name, **opts)

    cls.__init__ = __init__

    super_set = cls.__set__

    def __set__(self, instance, value):
        if len(value) >= self.size:
            raise ValueError('size must be < ' + str(self.size))
        super_set(self, instance, value)

    cls.__set__ = __set__
    return cls


# Specialized descriptors
@Typed(int)
class Integer(Descriptor):
    pass

@Unsigned
class UnsignedInteger(Integer):
    pass

@Typed(float)
class Float(Descriptor):
    pass


@Unsigned
class UnsignedFloat(Float):
    pass

@Typed(str)
class String(Descriptor):
    pass

@MaxSized
class SizedString(String):
    pass
```

## 代理`__getattr__`

<font color="red">`__getattr__()` 对于大部分以双下划线(__)开始和结尾的属性并不适用。</font> 比如，考虑如下的类：

```
class ListLike:
    """__getattr__对于双下划线开始和结尾的方法是不能用的，需要一个个去重定义"""

    def __init__(self):
        self._items = []

    def __getattr__(self, name):
        return getattr(self._items, name)
```

如果是创建一个ListLike对象，会发现它支持普通的列表方法，如append()和insert()， 但是却不支持len()、元素查找等。

为了让它支持这些方法，你必须手动的实现这些方法代理

代理类的实现

```python
class Proxy:
    def __init__(self, obj):
        self._obj = obj

    # Delegate attribute lookup to internal obj
    def __getattr__(self, name):
        print('getattr:', name)
        return getattr(self._obj, name)

    # Delegate attribute assignment
    def __setattr__(self, name, value):
        if name.startswith('_'):
            super().__setattr__(name, value)
        else:
            print('setattr:', name, value)
            setattr(self._obj, name, value)

    # Delegate attribute deletion
    def __delattr__(self, name):
        if name.startswith('_'):
            super().__delattr__(name)
        else:
            print('delattr:', name)
            delattr(self._obj, name)
            
```

使用这个代理类时，你只需要用它来包装下其他类即可：

```python
class Spam:
    def __init__(self, x):
        self.x = x

    def bar(self, y):
        print('Spam.bar:', self.x, y)

# Create an instance
s = Spam(2)
# Create a proxy around it
p = Proxy(s)
# Access the proxy
print(p.x)  # Outputs 2
p.bar(3)  # Outputs "Spam.bar: 2 3"
p.x = 37  # Changes s.x to 37
```

通过自定义属性访问方法，你可以用不同方式自定义代理类行为(比如加入日志功能、只读访问等)。

<font color="red">代理类有时候可以作为继承的替代方案。</font>例如，一个简单的继承如下：

```python
class A:
    def spam(self, x):
        print('A.spam', x)
    def foo(self):
        print('A.foo')

class B(A):
    def spam(self, x):
        print('B.spam')
        super().spam(x)
    def bar(self):
        print('B.bar')
```

使用代理的话，就是下面这样：

```python
class A:
    def spam(self, x):
        print('A.spam', x)
    def foo(self):
        print('A.foo')

class B:
    def __init__(self):
        self._a = A()
    def spam(self, x):
        print('B.spam', x)
        self._a.spam(x)
    def bar(self):
        print('B.bar')
    def __getattr__(self, name):
        return getattr(self._a, name)
```

## 通过类方法定义多个构造器

为了实现除`__init__`的多个构造器，你需要使用到类方法。

类方法的一个主要用途就是定义多个构造器。它接受一个 `class` 作为第一个参数(cls)。 你应该注意到了这个类被用来创建并返回最终的实例。在继承时也能工作的很好：

```
class NewDate(Date):
    pass

c = Date.today() # Creates an instance of Date (cls=Date)
d = NewDate.today() # Creates an instance of NewDate (cls=NewDate)
```

## 利用Mixins扩展类功能

使用场景：通常当你想自定义类的时候会碰上这些问题。可能是某个库提供了一些基础类， 你可以利用它们来构造你自己的类。我们可以写我们的功能类，这里的功能类里的方法和基础类一致，只是在基础类的方法里新增了很多内容，但是因为两者没有依赖关系又不好使用继承，可以考虑Mixins.

假设你想扩展映射对象，给它们添加日志、唯一性设置、类型检查等等功能。下面是一些混入类:

```python
class LoggedMappingMixin:
    """
    Add logging to get/set/delete operations for debugging.
    """
    __slots__ = ()  # 混入类都没有实例变量，因为直接实例化混入类没有任何意义

    def __getitem__(self, key):
        print('Getting ' + str(key))
        return super().__getitem__(key)

    def __setitem__(self, key, value):
        print('Setting {} = {!r}'.format(key, value))
        return super().__setitem__(key, value)

    def __delitem__(self, key):
        print('Deleting ' + str(key))
        return super().__delitem__(key)


class SetOnceMappingMixin:
    '''
    Only allow a key to be set once.
    '''
    __slots__ = ()

    def __setitem__(self, key, value):
        if key in self:
            raise KeyError(str(key) + ' already set')
        return super().__setitem__(key, value)


class StringKeysMappingMixin:
    '''
    Restrict keys to strings only
    '''
    __slots__ = ()

    def __setitem__(self, key, value):
        if not isinstance(key, str):
            raise TypeError('keys must be strings')
        return super().__setitem__(key, value)
```

这些类单独使用起来没有任何意义，事实上如果你去实例化任何一个类，除了产生异常外没任何作用。 它们是用来通过多继承来和其他映射对象混入使用的。例如：

```
class LoggedDict(LoggedMappingMixin, dict):
    pass

d = LoggedDict()
d['x'] = 23
print(d['x'])
del d['x']

from collections import defaultdict

class SetOnceDefaultDict(SetOnceMappingMixin, defaultdict):
    pass


d = SetOnceDefaultDict(list)
d['x'].append(2)
d['x'].append(3)
# d['x'] = 23  # KeyError: 'x already set'
```

混入类在标准库中很多地方都出现过，通常都是用来像上面那样扩展某些类的功能。 它们也是多继承的一个主要用途。比如，当你编写网络代码时候， 你会经常使用 `socketserver` 模块中的 `ThreadingMixIn` 来给其他网络相关类增加多线程支持。

例如，下面是一个多线程的XML-RPC服务：

```
from xmlrpc.server import SimpleXMLRPCServer
from socketserver import ThreadingMixIn
class ThreadedXMLRPCServer(ThreadingMixIn, SimpleXMLRPCServer):
    pass
```

同时在一些大型库和框架中也会发现混入类的使用，用途同样是增强已存在的类的功能和一些可选特征。

### 类装饰器实现混入类

```
def logged_mapping(cls):
    super_getitem = cls.__getitem__
    super_setitem = cls.__setitem__
    super_delitem = cls.__delitem__

    def __getitem__(self, key):
        print('Getting ' + str(key))
        return super_getitem(self, key)

    def __setitem__(self, key, value):
        print('Setting {} = {!r}'.format(key, value))
        return super_setitem(self, key, value)

    def __delitem__(self, key):
        print('Deleting ' + str(key))
        return super_delitem(self, key)

    cls.__getitem__ = __getitem__
    cls.__setitem__ = __setitem__
    cls.__delitem__ = __delitem__
    return cls

@logged_mapping
class Mydict(dict):
    pass
```

## 实现状态对象或者状态机

你想实现一个状态机或者是在不同状态下执行操作的对象，但是又不想在代码中出现太多的条件判断语句。

一个更好的办法是为每个状态定义一个对象.

```python
class Connection1:
    """新方案——对每个状态定义一个类"""

    def __init__(self):
        self.new_state(ClosedConnectionState)

    def new_state(self, newstate):
        self._state = newstate
        # Delegate to the state class

    def read(self):
        return self._state.read(self)

    def write(self, data):
        return self._state.write(self, data)

    def open(self):
        return self._state.open(self)

    def close(self):
        return self._state.close(self)


# Connection state base class
class ConnectionState:
    @staticmethod
    def read(conn):
        raise NotImplementedError()

    @staticmethod
    def write(conn, data):
        raise NotImplementedError()

    @staticmethod
    def open(conn):
        raise NotImplementedError()

    @staticmethod
    def close(conn):
        raise NotImplementedError()


# Implementation of different states
class ClosedConnectionState(ConnectionState):
    @staticmethod
    def read(conn):
        raise RuntimeError('Not open')

    @staticmethod
    def write(conn, data):
        raise RuntimeError('Not open')

    @staticmethod
    def open(conn):
        conn.new_state(OpenConnectionState)

    @staticmethod
    def close(conn):
        raise RuntimeError('Already closed')


class OpenConnectionState(ConnectionState):
    @staticmethod
    def read(conn):
        print('reading')

    @staticmethod
    def write(conn, data):
        print('writing')

    @staticmethod
    def open(conn):
        raise RuntimeError('Already open')

    @staticmethod
    def close(conn):
        conn.new_state(ClosedConnectionState)
```

每个状态对象都只有静态方法，并没有存储任何的实例属性数据。 实际上，所有状态信息都只存储在 `Connection` 实例中。 在基类中定义的 `NotImplementedError` 是为了确保子类实现了相应的方法。 

## 通过字符串调用对象方法

调用一个方法实际上是两部独立操作，第一步是查找属性，第二步是函数调用。 因此，为了调用某个方法，你可以首先通过 `getattr()` 来查找到这个属性，然后再去以函数方式调用它即可。

`operator.methodcaller()` 创建一个可调用对象，并同时提供所有必要参数， 然后调用的时候只需要将实例对象传递给它即可，比如：

```python
import math

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return 'Point({!r:},{!r:})'.format(self.x, self.y)

    def distance(self, x, y):
        return math.hypot(self.x - x, self.y - y)


p = Point(2, 3)
d = getattr(p, 'distance')(0, 0)  # Calls p.distance(0, 0)
```

```python
points = [
    Point(1, 2),
    Point(3, 0),
    Point(10, -3),
    Point(-5, -7),
    Point(-1, 8),
    Point(3, 2)
]
# Sort by distance from origin (0, 0)
points.sort(key=operator.methodcaller('distance', 0, 0))
```

```python
>>> p = Point(3, 4)
>>> d = operator.methodcaller('distance', 0, 0)
>>> d(p)
5.0
```

### operator模块

operator模块最特别的特性之一就是获取方法的概念，获取方法是运行时构造的一些可回调对象，<font color="red">用来获取对象的属性或序列的内容</font>，获取方法在处理迭代器或生成器序列的时候特别有用，它们引入的开销会大大降低lambda或Python函数的开销。

```python
from operator import *
class MyObj(object):
    def __init__(self, arg):
        super(MyObj, self).__init__()
        self.arg = arg
    def __repr__(self):
        return 'MyObj(%s)' % self.arg

objs = [MyObj(i) for i in xrange(5)]
print "Object:", objs

g = attrgetter("arg")
vals = [g(i) for i in objs]
print "arg values:", vals

objs.reverse()
print "reversed:", objs
print "sorted:", sorted(objs, key=g)
```

```python
def methodcaller(name, *args,  **kwargs):
      def caller(obj):
            return getattr(obj, name)(*args, **kwargs)
      return caller
```