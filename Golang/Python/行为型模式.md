# 模板方法模式

定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

## 使用步骤

1. 定义抽象类：定义抽象的原子操作(钩子操作); 实现一个模板方法的骨架
2. 定义具体类：实现原子操作(钩子操作)。

- 

## 实例

```python
from abc import ABCMeta, abstractmethod


class IOHandler(metaclass=ABCMeta):
    @abstractmethod
    def open(self, name):
        pass
    @abstractmethod
    def deal(self, change):
        pass
    @abstractmethod
    def close(self):
        pass

    def process(self, name, change):
        '''模板,就相当于是一个空盒子，可以往里面添加自己需要的功能。让这个函数去执行'''
        self.open(name)
        self.deal(change)
        self.close()


class FileHandler(IOHandler):
    def open(self, name):
        print('打开文件')

    def deal(self, change):
        print('操作文件')

    def close(self):
        print('关闭文件')

obj = FileHandler()
obj.process('abc.txt','')
```

## 适用场景

- **一次性实现一个算法的不变的部分**
- **各个子类中的公共行为应该被提取出来并集中到一个公共父类中以避免代码重复**
- **控制子类扩展**

# 策略模式

定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

## 使用步骤

1. 定义抽象策略(算法)
2. 定义具体算法
3. 定义上下文用于切换策略(组合)

## 实例

```python
from abc import ABCMeta, abstractmethod
import random

class Sort(metaclass=ABCMeta):
    @abstractmethod
    def sort(self, data):
        pass


class QuickSort(Sort):
    def quick_sort(self, data, left, right):
        if left < right:
            mid = self.partition(data, left, right)
            self.quick_sort(data, left, mid - 1)
            self.quick_sort(data, mid + 1, right)

    def partition(self, data, left, right):
        tmp = data[left]
        while left < right:
            while left < right and data[right] >= tmp:
                right -= 1
            data[left] = data[right]
            while left < right and data[left] <= tmp:
                left += 1
            data[right] = data[left]
        data[left] = tmp
        return left

    def sort(self, data):
        print("快速排序")
        return self.quick_sort(data, 0, len(data) - 1)


class MergeSort(Sort):
    def merge(self, data, low, mid, high):
        i = low
        j = mid + 1
        ltmp = []
        while i <= mid and j <= high:
            if data[i] <= data[j]:
                ltmp.append(data[i])
                i += 1
            else:
                ltmp.append(data[j])
                j += 1

        while i <= mid:
            ltmp.append(data[i])
            i += 1

        while j <= high:
            ltmp.append(data[j])
            j += 1

        data[low:high + 1] = ltmp


    def merge_sort(self, data, low, high):
        if low < high:
            mid = (low + high) // 2
            self.merge_sort(data, low, mid)
            self.merge_sort(data, mid + 1, high)
            self.merge(data, low, mid, high)

    def sort(self, data):
        print("归并排序")
        return self.merge_sort(data, 0, len(data) - 1)


class Context:
    def __init__(self, data, strategy=None):
        self.data = data
        self.strategy = strategy

    def set_strategy(self, strategy):
        self.strategy = strategy

    def do_strategy(self):
        if self.strategy:
            self.strategy.sort(self.data)
        else:
            raise TypeError


li = list(range(100000))
random.shuffle(li)

context = Context(li, MergeSort())
context.do_strategy()
# print(context.data)

random.shuffle(context.data)

context.set_strategy(QuickSort())
context.do_strategy()
```

## 适用场景

- **许多相关的类仅仅是行为有异**
- **需要使用一个算法的不同变体**
- 算法使用了客户端无需知道的数据

**一个类中的多种行为以多个条件语句的形式存在，可以将这些行为封装如不同的策略类中**

# 观察者模式

定义：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于他的对象都得到通知并被自动更新。

观察者模式又称‘发布-订阅’模式。

HF里面说，观察者模式可以用报纸出版商和报纸订阅者之间的关系来描述：
 报社出版报纸，可以将它看做一个生产者，报纸订阅者订阅报纸，可以将他看做一个个观察者。
 报社出版商可以提供以下的服务：

1. 注册一个报纸订阅者 (Register)
2. 注销一个报纸订阅者 (Remove)
3. 通知一个报纸订阅者 (Notify)

比如从气象站取得数据后要在三个布告牌显示这些数据，这两个布告牌显示的内容都不一样，一块实时显示气象数据，一块显示一段时间的统计数据，当数据变化时，这三个布告牌要按照自己的方式实时更新数据。例如，实时显示布告牌就显示当前最新数据，统计数据布告牌将最大值最小值平均值显示出来

## 使用步骤

1. 定义观察者基础类
2. 定义有特定数据变化方法的观察者类(继承观察者基础类)
3. 定义订阅者抽象类
4. 定义真实的订阅者，可以对数据的变化做自己的事

## 实例

```python
from abc import abstractmethod, ABCMeta


class Observer(object):
    def __init__(self):
        self._subscribers = []

    def register(self, subscriber):
        self._subscribers.append(subscriber)
        subscriber.update(self)

    def unregister(self, subscriber):
        self._subscribers.remove(subscriber)

    def notify_all(self):
        for subscriber in self._subscribers:
            subscriber.update(self)


class Subscriber(object, metaclass=ABCMeta):
    @abstractmethod
    def update(self, observer):
        pass


class WeatherObserver(Observer):
    def __init__(self, temp, pressure):
        super().__init__()
        self.temp = temp
        self.pressure = pressure

    def change_weather(self, temp, pressure):
        if self.temp != temp or self.pressure != pressure:
            self.notify_all()

class CurrentSubscriber(object, metaclass=ABCMeta):
    def __init__(self):
        self.curr_data = []

    def update(self, observer):
        self.curr_data.append((observer.temp, observer.pressure))


class StaticsSubscriber(object, metaclass=ABCMeta):
    def __init__(self):
        self.temps = []
        self.pressures = []

    def update(self, observer):
        self.temps.append(observer.temp)
        self.pressures.append(observer.pressure)

cs = CurrentSubscriber()
ss = StaticsSubscriber()
wo = WeatherObserver(12, 23)
wo.register(cs)
wo.register(ss)
wo.notify_all()
wo.change_weather(34, 56)
```

## 适用场景

- 当一个抽象模型有两方面，其中一方面依赖于另一方面。将这两者封装在独立对象中以使它们可以独立地改变和复用。
- 当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
- 当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换言之，你不希望这些对象是紧密耦合的

# 责任链模式

使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

## 使用步骤

1. 定义抽象处理者(抽象处理方法)
2. 具体处理者(必须有责任链的下一个节点)
3. 客户端一般使用最底层的处理者

## 实例

```python
from abc import abstractmethod, ABCMeta


class Handler(object, metaclass=ABCMeta):
    @abstractmethod
    def handle_leave(self, day):
        pass


class ManagerHandler(Handler):
    def handle_leave(self, day):
        if day <= 10:
            print('总经理准了')
        else:
            print('tmd')


class DepartmentHandler(Handler):
    def __init__(self):
        self.successor = ManagerHandler()

    def handle_leave(self, day):
        if day <= 3:
            print("部门经理批了")
        else:
            self.successor.handle_leave(day)


h = DepartmentHandler()
h.handle_leave(102)
```

## 适用场景

- 有多个对象可以处理一个请求，哪个对象处理由时间运行时决定
- 在不明确接受者的情况下，向多个对象中的一个提交一个请求





