interface 类型可以定义一组方法，但是这些不需要实现。并且 interface 不能包含任何变量。到某个 

自定义类型(比如结构体 Phone)要使用的时候,在根据具体情况把这些方法写出来(实现)。 

1. 接口里的所有方法都没有方法体，即接口的方法都是没有实现的方法
2. Golang中的接口，不需要显式的实现。只要一个变量，含有接口类型中的所有方法，那么这个变量就实现这个接口。因此，Golang 中没有 **implemen**t 这样的关键字 
3. 接口本身不能创建实例,但是<font color="red">可以指向一个实现了该接口的自定义类型的变量</font>.一个自定义类型只有实现了某个接口，才能将该自定义类型的实例(变量)赋给接口类型
4. 一个自定义类型可以实现多个接口
5. Golang中的接口可以继承，一个接口(比如 A 接口)可以继承多个别的接口(比如 B,C 接口)，这时如果要实现 A 接口，也必须将 B,C 接口的方法也全部实现。使用接口继承的时候，B和C不能有相同的方法
6. interface类型默认是一个指针(引用类型)，如果没有对interface初始化就使用，那么会输出nil
7. <font color="red">空接口 interface{} 没有任何方法，所以所有类型都实现了空接口, 即我们可以把任何一个变量赋给空接口。</font>

## 接口和继承的区别

1. 继承的价值主要在于:解决代码的复用性和可维护性。 接口的价值主要在于:设计，设计好各种规范(方法)，让其它自定义类型去实现这些方法。 
2. 接口比继承更加灵活，继承是满足 is - a 的关系，而接口只需满足 like - a 的关系。 
3. 接口在一定程度上实现代码解耦 

## 空接口

golang里的所有类型都实现了空接口interface{},所以通常将它作为一个函数的参数或者结构体的字段，以实现对类型的抽象。

## 类型断言

x.(T)

类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。

```go
func TypeJudge(items... interface{})  {
	for _, value := range items {
		switch value.(type) {
			case bool:
				fmt.Println("bool")
			case int:
				fmt.Println("int")
			default:
				fmt.Println("没有这种类型")
			
		}
	}
}

```

1. 如果断言的类型T是一个具体类型，然后类型断言检查x的动态类
   型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。
2. a.(type)只能和switch搭配使用