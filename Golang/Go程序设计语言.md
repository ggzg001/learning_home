# Golang

##  概览

1. 学习新语言比较自然的方式，是使用新语言写一些可以用其他语言实现的程序
2. Golang中的一个包由多个go文件组成，Golang的一个文件夹内必须只有一个包，否则编译就会出问题
3. 只有main包和main函数才可以被执行
4. golang的换行是有作用的，如 + ，后面换行可以但是在前面换行就不行
5. 和大多数语言一样，索引采用半开半闭的，维持统一的原则
6. 在一个包声明前，使用注释对其进行描述
7. golang中只有for循环，没有其他循环，其他循环都是根据for循环自动变化来的
8. 初始化和声明常用的两种模式：s := "" (不适合包级别的) 和 var s string  使用显式来说明初始化变量的重要性
9. Go 设计者思想: 一个问题尽量只有一个解决方法



## 名称

* 区分大小写
* 包名一般小写
* 大写的变量可以跨包，小写的不可以
* 函数外对整个包的所有文件可见，函数内只对函数可见
* 名称长度没有限制，但是Go更倾向于短的，越短说明作用域越小
* 首字母缩写词一般都大写，如HTMLEscape,而不是HtmlEscape

---

## 声明

Golang有4个主要的声明：变量(var)、常量(const)、类型(type)和函数(func).

Go程序的文件，以package开头，然后import声明，然后是包级别的类型、变量、常量和函数的声明，不区分顺序。

***

## 变量

`var name type = expression` 

* 类型和表达式缺一不可
* Go中不存在未初始化变量，因为默认有零值，使得变量一开始就是可用的状态
* Golang中变量的三要素：名称、值和类型
* 声明了一个变量，值必须在类型的可控范围内，否则编译器静态报错

### 短变量声明

`name := expression`

* 常用于局部变量的声明
* var用于后面才对变量赋值以及变量初始值不重要的情况或者初始化表达式类型和值不一致的情况
* 短边量声明最少需要一个是未声明的变量

### 指针

1. 指针类型的零值是nil
2. 指针是可以相互比较的，当两个指针当且仅当指向同一个变量或者两者都是nil才相等
3. 指针的本质其实就是别名去访问变量，而不用再通过变量名去访问变量

### new

`new(T)` 创建一个T类型的变量，返回地址，new函数使用的较少。因为在new结构体变量或者切片的时候回有一些问题，这个可以再看.每次调用new函数得到的都是一个新地址

## 常量

1. 常量一般都是大写
2. 如果想要私有，那么一般在前面加一个小写字母c
3. Go中常量可以定义不使用，但是变量定义后不使用会panic

### iota

Go底层自动维护的一个计数器，当使用const定义常量组的时候，初始化一个iota, 初始值为0.每当在常量组定义一个常量，iota会自动加1.直到下一个const常量组这个关键词出现时，在那个常量组又变为0

```go
const (
		a = iota // 0
		b  // 1
		c  // 2
		d = "ta" // iota = 3
		e // "ta"  iota = 4
		f = 100  // iota = 5
		g // 100
		h = iota // iota = 7
		i // 8
	)


```







[x] Golang的垃圾回收机制？逃逸分析？

## 赋值

### 多重赋值

如果map查询，类型断言或者管道接收出现在两个结果的赋值语句中，都会产生一个额外的布尔型结果。

### 可赋值性

类型必须精准匹配，常量有更灵活的可赋值性规则来规避显式的转换。两个值使用 == 或者 != 进行比较和可赋值性相关。

## 类型声明

`type name underlying-type`

Golang中对变量使用了类型约束。类型定义了这些变量的值应有的特性，比如大小、在内部如何表达、可以对其进行何种操作以及它们相互关联的方法。

* 类型的声明通常放在包级别
* 使用类型声明后，声明的类型之间的操作借用的是底层类型的操作
* 命名类型的值可以与其相同的命名类型或者底层类型相同的未命名类型的<font color="red">值</font>进行比较，但是不同命名类型不能直接比较

## 包和文件

* 每个包都有对应的名称空间，image.Print 前面的image可以看做是包的隔离



### 包的初始化

1. init函数可以重复声明，但是一般不这么做
2. 初始化的工作是自下而上的，也就是说main包是最后被初始化
3. import 一个包时，该包的多个go文件会被go的构建工具排序，依次调用编译器编译


## 作用域

作用域对应的是一个源代码的文本区域，它是一个编译时的属性。变量的生命周期是指程序运行时变量的有效时间，是一个运行时的概念。

1. 句法块
2. 词法块

---

* Golang中花括号就表示一个块
* 编译器遇到一个名字引用时，如果看起来像是一个声明，首先会从内部词法域往全局词法域查询，查询不到就报错
* 在包级别，声明的顺序不会影响作用域范围，因此一个先声明的可以引用它后面声明的变量
* Go的习惯是在if中处理错误直接返回

```Go
func main(){
	//if f, err := os.Open("name"); err != nil {
	//	return err
	//} else {
	//	f.Close()
	//}
	f, err := os.Open("name")
	if err != nil {
		return
	}
	f.Close()
}
```

## 格式化输出

Printf 是格式化输出，Golang的格式化输出与python的格式化输出不太一样，go的格式化需要格式类型完全匹配，那么这里的格式化输出的格式是什么意思呢？例如%2d, 或" ====%2d=="这种形式，不仅打印值，还打印其他配合信息等。

通用：

```go
%v	值的默认格式表示
%+v	类似%v，但输出结构体时会添加字段名
%#v	值的Go语法表示
%T	值的类型的Go语法表示
%%	百分号
```

布尔值：

```
%t	单词true或false
```

整数：

```go
%b	表示为二进制
%c	该值对应的unicode码值
%d	表示为十进制
%o	表示为八进制
%q	该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示
%x	表示为十六进制，使用a-f
%X	表示为十六进制，使用A-F
%U	表示为Unicode格式：U+1234，等价于"U+%04X"
```

浮点数与复数的两个组分：

```go
%b	无小数部分、二进制指数的科学计数法，如-123456p-78；参见strconv.FormatFloat
%e	科学计数法，如-1234.456e+78
%E	科学计数法，如-1234.456E+78
%f	有小数部分但无指数部分，如123.456
%F	等价于%f
%g	根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）
%G	根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）
```

字符串和[]byte：

```go
%s	直接输出字符串或者[]byte
%q	该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示
%x	每个字节用两字符十六进制数表示（使用a-f）
%X	每个字节用两字符十六进制数表示（使用A-F）    
```

指针：

```go
%p	表示为十六进制，并加上前导的0x 
```

## 键盘输入

1. Scan: 将连续由空格分隔的值存储为连续的实参。换行符计为空格, 就是说可以换行，Scan里面写了几个就匹配到几个为止。同时兼顾声明的变量格式和空格
2. Scanln:  将连续由空格分隔的值存储为连续的实参,与Scan的区别是换行代表结束。同时兼顾声明的变量格式和空格
3. Scanf: 输入格式由格式决定，可以不再是空格分割，`%d,%d`就表示用`,`分割，但是还是以换行表示结束
4. bufio.NewReader：处理前三者以空格分割的问题

```go
reader := bufio.NewReader(os.Stdin)
data, _, _  := reader.ReadLine()
fmt.Println(string(data))
```





​                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       




                                                                                                                                                                                                                                                                                                                                                                 














