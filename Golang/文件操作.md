文件操作从最基础的一步步来

# 创建文件并往里写东西

```go
package main

import (
	"fmt"
	"os"
)

func main()  {
	fp, err := os.Create("./a.txt")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer fp.Close()
	// fp.WriteString("hello\n我是")
    fp.Write([]byte{'h', 'e', 'l'})
    // 从0开始，到第三个位置开始往后写内容，并会覆盖原先的内容
	fp.WriteAt([]byte{'a'}, 3)

}
```

```go
func Create(name string) (*File, error) {
	return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
}
```

Create的时候不存在文件会创建文件，文件存在并且有内容会清空文件内容

# 指针移动

```go
package main

import (
	"fmt"
	"io"
	"os"
)

func main()  {
	fp, err := os.Create("./a.txt")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer fp.Close()
	fp.WriteString("hello\n我是")
	// 如果是末尾了，offset 的值是正数就不合适了，此时得到的文件会有乱码(不是想到的空格)
	n, _ := fp.Seek(0, io.SeekEnd)
	// 从0开始，到第三个位置开始往后写内容，并会覆盖原先的内容
	fp.WriteAt([]byte{'a'}, n)

}
```

# 读取文件

## 全部读取

```go
package main

import (
	"fmt"
	"os"
    "io"
)

func main()  {
	fp, err := os.Open("./a.txt")
	if err != nil {
		fmt.Println(err)
		return
	}
	defer fp.Close()

	buf := make([]byte, 30)
	n, err := fp.Read(buf)
	if err != nil && err != io.EOF {
		fmt.Println(err)
		return
	}
	fmt.Println(string(buf[:n]))

}
```

全部读取的话声明的slice的大小不确定，声明小了，数据读取不全，声明大了就会浪费内存.还有一种封装更加彻底的方式：

```go
package main

import (
	"fmt"
	"io/ioutil"
)

func main()  {
	data, err := ioutil.ReadFile("./a.txt")
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println(string(data))

}
```

此时文件的打开和关闭操作都在内部封装

## 一行行读取

一行行读取需要借助缓冲区，先把磁盘的数据一次性读到缓冲区(数据太大，缓冲区小的情况下也可以分批次读到缓冲区，总好过多次访问磁盘要好)，然后从缓冲区一行行地拿。

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

func main()  {
	fp, err := os.OpenFile("./a.txt", os.O_RDWR, 0666)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer fp.Close()
	reader := bufio.NewReader(fp)
	//reader := bufio.NewReader(fp)
	for {
		data, err := reader.ReadString('\n')
		fmt.Print(string(data))
		if err == io.EOF {
			break
		}
	}
}
```

# 写文件

os.OpenFile 

```go
func OpenFile(name string, flag int, perm FileMode) (file *File, err error)
```

OpenFile是一个更一般性的文件打开函数，大多数调用者都应用Open或Create代替本函数。它会使用指定的选项（如O_RDONLY等）、指定的模式（如0666等）打开指定名称的文件。如果操作成功，返回的文件对象可用于I/O。如果出错，错误底层类型是*PathError。

flag:

```go
const (
    O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件
    O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件
    O_RDWR   int = syscall.O_RDWR   // 读写模式打开文件
    O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部
    O_CREATE int = syscall.O_CREAT  // 如果不存在将创建一个新文件
    O_EXCL   int = syscall.O_EXCL   // 和O_CREATE配合使用，文件必须不存在
    O_SYNC   int = syscall.O_SYNC   // 打开文件用于同步I/O
    O_TRUNC  int = syscall.O_TRUNC  // 如果可能，打开时清空文件
)
```

## 创建一个新文件，写入内容 5 句 "hello"

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main()  {
	fp, err := os.OpenFile("./a.txt", os.O_WRONLY | os.O_CREATE, 0666)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer fp.Close()

	//for i := 0; i < 5 ;i++ {
	//	fp.WriteString("hello\n")
	//}

	writer := bufio.NewWriter(fp)
	for i := 0; i < 5; i++ {
		writer.WriteString("hello\n")
	}
	// 数据是先进缓存，最后需要手动把缓存数据一次性刷到硬盘
	writer.Flush()
}
```

## 打开一个存在的文件中，将原来的内容覆盖成新的内容 10 句 "你好!"

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main()  {
	fp, err := os.OpenFile("./a.txt", os.O_WRONLY | os.O_TRUNC, 0666)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer fp.Close()

	//for i := 0; i < 5 ;i++ {
	//	fp.WriteString("hello\n")
	//}

	writer := bufio.NewWriter(fp)
	for i := 0; i < 5; i++ {
		writer.WriteString("你好\n")
	}
	// 数据是先进缓存，最后需要手动把缓存数据一次性刷到硬盘
	writer.Flush()
}
```

## 打开一个存在的文件，在原来的内容追加内容 'ABC! '

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main()  {
	fp, err := os.OpenFile("./a.txt", os.O_WRONLY | os.O_APPEND , 0666)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer fp.Close()

	writer := bufio.NewWriter(fp)
	writer.WriteString("ABC!\n")
	// 数据是先进缓存，最后需要手动把缓存数据一次性刷到硬盘
	writer.Flush()
}
```

## 打开一个存在的文件，将原来的内容读出显示在终端，并且追加 5 句"hello!"

```go
package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

func main()  {
	fp, err := os.OpenFile("./a.txt", os.O_RDWR , 0666)
	if err != nil {
		fmt.Println(err)
		return
	}
	defer fp.Close()
	reader := bufio.NewReader(fp)
	for {
		data, err := reader.ReadString('\n')
		fmt.Print(string(data))
		if err == io.EOF {
			break
		}
	}
	// 此时fp的指针在文件末尾了
	writer := bufio.NewWriter(fp)
	writer.WriteString("hello!\n")
	// 数据是先进缓存，最后需要手动把缓存数据一次性刷到硬盘
	writer.Flush()

}
```

## 复制文件的两种方式

```go
package main

import (
   "fmt"
   "io/ioutil"
)

func main()  {
   data, err := ioutil.ReadFile("./a.txt")
   if err != nil {
      fmt.Println(err)
      return
   }
   // 没有文件会创建文件，有文件会清空内容
   ioutil.WriteFile("./b.txt", data, 0666)

}
```

```go
package main

import (
   "bufio"
   "fmt"
   "io"
   "os"
)

func main()  {
   fp, err := os.OpenFile("./a.txt", os.O_RDONLY, 0666)
   if err != nil {
      fmt.Println(err)
      return
   }
   reader := bufio.NewReader(fp)

   fp2, err := os.OpenFile("./c.txt", os.O_WRONLY | os.O_CREATE, 0666)
   if err != nil {
      fmt.Println(err)
      return
   }
   writer := bufio.NewWriter(fp2)
   io.Copy(writer, reader)
   writer.Flush()
}
```

# 判断文件存在与否

```go
func PathExists(path string) (bool, error) {
   _, err := os.Stat(path)
   if err == nil {
      return true, err
   }
   if os.IsNotExist(err) {
      return false, err
   }
   return false, err
}
```

# 递归遍历目录下的所有文件

```go

package main

import (
	"fmt"
	"os"
	"path/filepath"
)

func walkFunc(path string, info os.FileInfo, err error) error {
	if !info.IsDir() {
		fmt.Printf("%s\n", path)
	}
	return nil
}

func main() {
	//遍历打印所有的文件名
	filepath.Walk("/Users/guwanhua/go/src/go_code", walkFunc)
}
```

# 遍历一级目录下的文件和目录

```go
package main

import "fmt"
import "io/ioutil"

func main() {
	dir_list, e := ioutil.ReadDir("/Users/guwanhua/go/")
	if e != nil {
		fmt.Println("read dir error")
		return
	}
	for i, v := range dir_list {
		fmt.Println(i, "=", v.Name())
	}

}


```

# 获取当前文件路径

```go
import (
	"errors"
	"runtime"
)
 
func CurrentFile() string {
	_, file, _, ok := runtime.Caller(1)
	if !ok {
		panic(errors.New("Can not get current file info"))
	}
	return file
}

```

Caller的参数：

* 0 表示调用runtime.Caller()所在的位置，1表示runtime.Caller()所在函数的调用位置，依此类推

* 写死1则始终得到的是调用CurrentFile()所在的位置，此函数能在任意调用