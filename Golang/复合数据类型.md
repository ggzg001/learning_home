## 数组

数组是固定长度的序列，因为长度固定，所以Golang中很少直接使用数组，更多的使用slice,但是slice的基础是数组。

### 数组的声明

```go
var q [3]int = [3]int{1,2,3}
var q [3]int = [3]int{0:1, 1:2, 2:3}
var q = [...]int{1,2,3}
```

1. 数组，slice，map和结构体字面值的写法都很类似。

2. 数组的长度必须在编译阶段确定，所以数组的 长度必须是常量表达式。
3. 数组的元素类型如果是可以比较的，那么这个数组类型也可以相互比较
4. Golang函数调用传递的是副本，所以把大的数组当做参数传进去是低效的，所以很少把数组当做函数参数。这一点和python不同，python传的是引用，可以直接修改list。
5. Golang中的数组相当于python中的元组, 所以操作及其有限

```go
func main()  {
	var aArr = [3]string{"ha", "j", "wp"}
	fmt.Println(aArr)
	//	fmt.Println(string(aArr))
	// aArr[:] 就是切片了
	//fmt.Println(strings.Join(aArr[:], ","))
	//s := fmt.Sprint(aArr)
	//fmt.Printf("%q\n", s)
	//fmt.Printf("%q\n", strings.Replace(strings.Trim(s, "[]"), " ", ",", -1))

	//aArr1 := append(aArr[:], "ass")
	//// []string
	//fmt.Printf("%T", aArr1)

	// [3]string does not implement sort.Interface (missing Len method), aArr 没有实现接口方法
	//sort.Reverse(aArr)
	fmt.Println(len(aArr))
}
```



## slice

虽然通过指针来传递数组参数是高效的，但是数组依然是僵化的数据类型，因为数组长度不可变，参数如果是[16]byte那么就不能接收[32]byte的数据。从而引出了slice,slice和数组很像，只是没有了长度的限制。Go中的slice类似于python中的list, 使用广泛，而且Go中很多函数和方法针对的参数也是slice.

1. slice是引用类型，可以看做是一个结构体，包含一个指向数组的指针，len和cap三部分。len对应slice元素的数目，cap一般是从slice第一个元素的位置到slice底层数组的末尾数据的位置
2. 如果切片超出了cap(s) 的上限会导致panic异常，超出len(s)意味着拓展了slice.想要动态提升cap，可以使用append内置函数
3. slice是引用类型，所以切片的时间复杂度是常量
4. slice含有指向数组的指针，所以传递slice可以修改不定长度的数组的元素值

```go
func reverse(s []int)  {
	for i, j := 0, len(s) - 1; i < j; i, j = i+1, j-1 {
		s[i], s[j] = s[j], s[i]
	}
}
```

### slice的声明

1. 对数组的切片
2. 直接赋值`s := []int{1, 2, 3}`,这种方式会隐式地创造一个数组，然后slice指向这个数组
3. `make([]T, len,cap)` cap可以省略，此时cap=len, 这种方式也会隐式地创造一个数组
4. 和数组不同的是，slice不能比较(考虑到slice可以扩容的原因)，用户需要自己展开元素进行比较.slice唯一的比较操作是和nil进行比较，一个nil值得slice没有底层数组
5. var aArr []string` 此时得到的slice==nil
6. `var aArr = []string{}` 此时slice != nil

#### make slice的参数不同带来的不同效果

go语言的书上一般都会告诉我们，当切片有足够大小的时候，append操作是非常快的。但是当给出初始大小后，我们得到的实际上是一个含有这个size数量切片类型的空元素

```go
var aArr = make([]int, 5)
aArr = append(aArr, 3) // [0 0 0 0 0 3]
```

make的第三个参数，容量，也就是我们通过传递给make，0的大小和足够大的容量.

```go
var aArr = make([]int, 0, 5)
aArr = append(aArr, 3) // [3]
```



### nil值的slice

`s := []int{nil}`

一个nil值的slice的行为和其它任意0长度的slice一样，除了特殊说明，Go语言函数应该以相同的方式对待nil值的slice和0长度的slice

### append函数

append函数首先会判断底层的数组是否有足够容量保存新元素，如果有直接扩容。没有会创建新的数组然后进行数值的拷贝。每一次的append操作都不能确认新的slice和原来的slice是否引用新的数组，同样我们不能确认在原来的slice上的修改是否会影响新的slice,所以通常把append的结果赋给新的slice.

append函数主要是为了扩大cap的，如果在cap之内就谈不上扩容了。

### copy

`copy(dest, src)`参数顺序和 `dest = src`统一。在使用copy复制切片之前，要保证目标切片有足够的大小，注意是大小，而不是容量

###  slice的增删改查

Golang中没有针对slice的很多增删改查的API, 可以通过append函数的操作来达到增删改查的效果

#### 删除

```go
var aArr = []string{"a", "b"}
index := 1
// 删除
aArr = append(aArr[:index], aArr[index+1:]...)
fmt.Println(aArr)
```



#### 插入

```go
var aArr = []string{"a", "b"}
// 需要插入的位置
index := 1

rear := append([]string{}, aArr[index:]...)
aArr = append(aArr[:index], "insertded")
aArr = append(aArr, rear...)
```





## map

map是一种引用类型，类型是map[T]V, 其中T是统一的类型，V是统一的类型，T必须是可以比较的类型(所以map可以通过测试key是否相等来判断是否已经存在).目标切片大小0，容量10，copy不能复制。目标切片大小小于源切片大小，copy就按照目标切片大小复制，不会报错。

当我们使用make初始化切片的时候，必须给出size。go语言的书上一般都会告诉我们，当切片有足够大小的时候，append操作是非常快的。但是当给出初始大小后，我们得到的实际上是一个含有这个size数量切片类型的空元素

```
func main(){
    var ss=make([]string,10);
    ss=append(ss,"last");
    print("after append",ss)
    
}
```

实际上，此时我们应该先用下标为切片元素负值。但是如果我们既想有好的效率，有想继续使用append函数而不想区分是否有空的元素，此时就要请出make的第三个参数，容量，也就是我们通过传递给make，0的大小和足够大的容量数值就行了。

```
func main(){
    var ss=make([]string,0,10);
    ss=append(ss,"last");
    print("after append",ss)
    
}
```





### map的声明

```go
ages := make(map[string]int)
ages := map[string]int{"jack": 23,}
ages := make(map[string]int)
ages["jack"] = 23
```

`ages := make(map[string]int)`表示创建一个空map,内存底层已经有了map，ages 只不过是一个指向操作。另一种创建空map的方式是`ages := map[string]int{}`

### 空map和nil的map

```go
ages := make(map[string]int)
fmt.Println(ages == nil) // false

var args map[string]int
fmt.Println(args == nil) // true
fmt.Println(len(args))  // 0

ars := map[string]int{}
fmt.Println(ars == nil)  // false
fmt.Println(len(ars))  // 0
```

map的零值是nil，就是没引用任何哈希表。map的增删改查操作也适用于nil值的map上。

对于`var args map[string]int`，向一个nil值map存值会panic,需要先分配内存才能存数据。

map的下标语法还有另外一种应用：`value, ok = ages["jack"]`,这是map的下标语法

### map的增删改查

* 增加`ages["jack"]=23`
* 删除`delete(ages,"jack")`
* map的操作是安全的，即使元素不在map中也不会报错。查找失败返回零值，相当于python中的dict.get
* map的元素不是变量，不能进行取址操作`_ = &ages["jack"]`

### map的比较

和slice一样，map之间不能进行相等比较，唯一的例外是和nil进行比较。map间的比较需要用户自己实现

```go
func equal(x, y map[string]int) bool {
	if len(x) != len(y) {
		return false
	}
	for k1, v1 := range x {
		// 不能使用这种判断方式，因为取不到值默认可能取零值0，如果此时恰好另外一个map的value也是0
		//if y[k1] != v1 {
		//	return false
		//}
		if v2, ok := y[k1]; !ok || v2 != v1 {
			return false
		}
	}
	return true
}
```

### map元素排序

```go
func sorted(x map[string]int)  {
	bs := make([]string, len(x))
	for key := range x {
		bs = append(bs, key)
	}
	sort.Strings(bs)
	for _, key := range bs {
		fmt.Println(key, x[key])
	}
}
```

### map创造set效果

Go中没有set的数据结构，可以利用map的key不重复模拟set的效果

```go
func main(){
	seen := make(map[string]bool)
	input := bufio.NewScanner(os.Stdin)
	for input.Scan() {
		line := input.Text()
		if !seen[line] {
			seen[line] = true
			fmt.Println(line)
		}
	}
	if err := input.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "dedup:%v\n", err)
		os.Exit(1)
	}

}
```

#### ReadRune

```go
func main(){
	counts := make(map[rune]int)
	reader := bufio.NewReader(os.Stdin)
	// ReadRune 只读一个rune，即使有多个rune也只读一个,不是用换行或者空格分割
	r, n, err := reader.ReadRune()
	// 读到文件末尾会有一个错误
	if err == io.EOF {
		fmt.Println(err)
	}
	fmt.Printf("%c, %d, %v, %v", r,n,err, counts)
}
```

#### map的key是slice

map的key必须是可比较的，但是slice不可比较。所以可以把slice转化为string,`fmt.Sprintf("%q",lis)` 就可以完成转换。



## 结构体

Golang中的结构体对应python中的对象，可以使用点操作符访问成员。结构体属于值类型，所以可以对成员取地址，然后通过地址访问修改。

1. 结构体成员的输入顺序有重要意义，类似于python的init的参数也是有顺序的
2. 一个结构体可以同时包含导出和未导出的成员，类似于python中的对象属性是否可见(双下划线)
3. 一个命名为S的结构体不能再包含S类型的成员，一个聚合的值不能包含自身，但是可以包含*s指针类型的成员，用于创建递归的数据结构，比如链表和树。<u>插入排序</u>
4. 结构体的所有字段在内存中是连续的

### 声明

```go
type Employee struct {
	id int
	name string
}
e := Employee{1,"jack"} // 不能省略
e := Employee{id:1}  // 可以省略
```

### 作为形参

结构体可以作为函数的参数和返回值，如果考虑效率的话通常使用指针。而且，要想修改结构体内部成员，必须传指针，因为Golang是值拷贝，传地址就是拷贝地址的值，相当于多了一个引用。

### 结构体的比较

如果结构体的全部成员都是可以比较的，那么结构体就是可以比较的，比较的时候使用字段相互对应，不与字段定义顺序关联。

### 匿名成员和结构体嵌入

Golang中有一个语言特性，可以只声明一个成员对应的数据类型而不指定成员的名字，这类成员就是匿名成员，匿名成员的数据类型必须是命名的数据类型或指向一个命名的类型的指针。

```go
import "fmt"

type Point struct {
	x, y int
}

type Circle struct {
	Point
	Radius int
}
func main()  {
	var c Circle
	c.Radius = 10
	c.x = 10
	c.Point.y = 10
	fmt.Println(c)
	}
```

* 匿名成员的名字就是命令的类型名字
* 匿名成员通过字面量的形式需要指定Point参数了
* 如果成员没有导出，那么简短的匿名成员访问方式是非法的

### 方法

1. 方法绑定时的变量可以使用其类型的第一个字母
2. 由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个X方法的话，编译器会报错

#### 方法的调用

1. 通过一个变量去调用方法时，其调用机制和函数一样
2. 不一样的地方时，变量调用方法时，该变量本身也会作为一个参数传递到方法(如果变量是值类型，则进行值拷贝，如果变量是引用类型，则进行地质拷贝) 
3. 方法的访问范围控制的规则，和函数一样。方法名首字母小写，只能在本包访问，方法首字母
   大写，可以在本包和其它包访问
4. 如果一个类型实现了 String()这个方法，那么 fmt.Println(&stu) 默认会调用stu这个变量的 String()进行输
   出

#### 方法调用编译器做的事

不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。



### 工厂模式

使用工厂模式实现跨包创建结构体。

```go
type student struct {
	name string
}

func NewStudent(name string) *student {
	return &student{
		name: name,
	}
}

func (s *student) Name() string {
	return s.name
}
```









## json

json数组用于编码数组和slice, json对象用于编码map和结构体

### 序列化

```go
var movies = []string{"jack", "alex"}
// prefix： 每一行输出的前缀，indent表示每一个层级的缩进
data, _ := json.MarshalIndent(movies, "", "  ")
// 把[]byte打印成字符串
fmt.Printf("%s", data)
```

结构体Tag：Color bool `json:"color,omitempty"`

omitempty表示Go的结构体成员为空或零值的时候该结构体成员不生成在json对象里面。

### 反序列化

通过定义合适的数据结构，我们可以选择性解码JSON中感兴趣的数据。

```go
package main

import (
	"encoding/json"
	"fmt"
)

type Student struct {
	Name string `json:"name"`
	//Age int `json:"age,omitempty"`
}


func main() {
	var s Student
	data := "{\"age\": 23, \"name\": \"jack\"}"
	json.Unmarshal([]byte(data), &s)
	fmt.Println(s)
}
```





html/template 就是为了给浏览器展示用的？

Html 的自动转义是什么意思？避免输入和html格式冲突







函数返回不定参数，返回一个或者返回两个参数是怎么做到的？

map的地址是怎么在内存中存在的？

make 函数的第三个参数是怎么用的，为啥有些有第三个参数，有些则没有，有啥影响？

slice的nil还是数组的nil?

Slice 为啥也需要make？

二叉树实现插入排序，在复合数据类型 结构体 那一章。

匿名成员和组合的关系？

map、slice以及数组之间的相互组合，或者说类型约束

text/template和html/template的区别？

go doc text/template

看透书籍作者的写书的风格，猜测他可能想表达的含义

Time 模块？失败重试使用了time模块

Log模块干了些啥事？

Eprintf 又干了些什么？

Panic 类似于assert

Runningtime 模块？

defer + recorver + panic 是怎么配合使用的？

结构体嵌入和组合、继承的关系？

键盘输入与输出？







