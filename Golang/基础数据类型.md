# 整型

Go的数值类型包括整数、浮点数和复数。

* 整型分为有符号(包含负数)和无符号整型，无符号数往往在位运算和其他特殊场合才能使用
* int的位数取决于操作系统。
* rune是int32的缩写，通常表示一个unicode码点，这两个名称可以互换使用(可以相互比较，不需要强转等)。
* byte是uint8的缩写，用于强调数值是一个原始的数据而不是一个小的整数。
* 算数运算符(包含/,不包含%)适用于整数、浮点数和复数，但是取模运算仅适用于整数运算。而且对于不同的编程语言。%取模运算的行为可能并不相同。在Go中，%运算得到的结果的符号与第一个数的符号相同。除法运算的行为依赖于操作数是否全为整数。
* 数值操作如果溢出，那么高位会被截断，只保留低位。
* 只有相同类型的值可以进行算数和逻辑运算，虽然这偶尔会让表达式很长，但是消除了所有不确定性，使得程序易于理解。这也是Golang的思想之一。
* 强制类型转换T(x)，如果是允许的操作那么仅仅是告诉编译器如何解释这个值。但是如果把大尺寸转为小尺寸，就可能会改变数值或丢失精度。如浮点数到整数的转换就会丢失小数部分


```
var n  = 23
fmt.Printf("%d, %[1]v, %[1]o",n)
```
%[1] 的 1 表示继续引用第一个参数。
%c 是字符打印(字符而非字符串)，%q表示打印带引号的

printf的几个格式化的东西？
%f 打印浮点数

# 浮点数

浮点数的范围极限可以在math包中找到，常量math.MaxFloat32表示float32能表示的最大数值。

1. 通常情况下，应该使用 float64 ，因为它比 float32 更精确。[开发中，推荐使用 **float64**]
2. Golang 的浮点型默认声明为 float64 类型

# 布尔型

1. !true 比 (!true==false)==true更简洁，推荐使用更简洁的方式

2. && 比 || 的优先级更高，所以常常在写if条件的时候不需要加括号

3. 与python不同，Golang中的布尔值不会隐式转为0或1  `return i != 0`

   

# 字符

Golang中的字符和其他语言一样，本质上存的是数值，但是与python等不同的是，Golang中的字符在使用时更体现底层存储，默认的打印也是数值，需要格式化成字符打印。也正因为如此，字符类型是可以进行运算的，相当于一个整数



# 字符串

1. Golang中的字符串是一个不可改变的字节序列，len的结果是字节数而不是字符数
2. `+`可以把两个字符串链接构造成一个新的字符串，字符串太多时，需要把+放在上一行
3. 字符串的值是不可变的：一个字符串包含的字节序列永远不会改变，所以尝试修改字符串内部的值是非法的。不变的好处是可以共享内存，底层数据是安全的，切片不需要耗费额外的内存，只需要重新引用即可
4. Golang中支持原生字符串，可以跨行，相当于python中的r""，常用于编写正则
5. 字符串两种表示形式：双引号和反引号(原生含义，可以去除转义等)

## 字符串常用方法

```go
* 查找子串是否在指定的字符串中: strings.Contains("seafood", "foo")
* 统计一个字符串有几个指定的子串 strings.Count("ceheese", "e") //4
* 不区分大小写的字符串比较(==是区分字母大小写的): fmt.Println(strings.EqualFold("abc", "Abc")) // true
* 返回子串在字符串第一次出现的 index 值，如果没有返回-1 : strings.Index("NLT_abc", "abc") // 4
* 返回子串在字符串最后一次出现的 index，如没有返回-1 : strings.LastIndex("go golang", "go")
* 将指定的子串替换成 另外一个子串: strings.Replace("go go hello", "go", "go 语言", n) n 可以指 定你希望替换几个，如果 n=-1 表示全部替换
* 按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组:strings.Split("hello,wrold,ok", ",")
* 将字符串的字母进行大小写的转换: strings.ToLower("Go") // go strings.ToUpper("Go") // GO
* 将字符串左右两边的空格去掉: strings.TrimSpace(" tn a lone gopher ntrn ")
* 将字符串左右两边指定的字符去掉 : strings.Trim("! hello! ", " !")
* 将字符串左边指定的字符去掉 : strings.TrimLeft("! hello! ", " !")
* 判断字符串是否以指定的字符串开头: strings.HasPrefix("ftp://192.168.10.1", "ftp") 
* 判断字符串是否以指定的字符串结束: strings.HasSuffix("NLT_abc.jpg", "abc")

```



## 字符串和byte切片

标准库有四个包对于处理字符串比较重要：bytes、strings、strconv和unicode包

1. 因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制，使用bytes.Buffer类型更有效
2. strconv提供了布尔型，整数、浮点数和对应字符串的相互转换
3. 字符串是一个只读的字节数组，一旦创建，不可修改。相比之下，一个字节slice的元素则可以进行修改

```Golang
func comma(s string) string {

	n := len(s)
	if n <= 3 {
		return s
	}
	return comma(s[:n-3]) + "," + comma(s[n-3:])
}

func basename(s string) string {
	slash := strings.LastIndex(s, "/")
	s = s[slash + 1:]
	if dot := strings.LastIndex(s, "."); dot > 0 {
		s = s[:dot]
	}
	// 里面可以有两个for循环， if的条件判断使用的字符，不是字符串
	
	//for i := len(s) -1; i >= 0; i-- {
	//	if s[i] == '/' {
	//		s = s[i+1:]
	//		break
	//	}
	//}
	//for i := len(s) - 1; i >= 0; i-- {
	//	if s[i] == '.' {
	//		s = s[:i]
	//		break
	//	}
	//}

	return s
}
```

## 字符串和字节slice的转换

```
var s = "hello world"
fmt.Printf("%v\n", s)
fmt.Println(s)
var b = []byte(s)
fmt.Println(b)
var sb = string(b)
fmt.Println(sb)
```
从概念上讲，从string到[]byte是分配了新的内存用于数据拷贝，编译器的优化知识可以避免在某些场景下分配和复制字符串，但是总体还是确保字符串的可读性。为了避免转换中不必要的内存分配，strings有6个函数：
```
Contains
Count
Fields
HasPrefix
Index
Join
```

## 字符串和基本数据类型之间的转换

### 字符串转基本数据类型

借助strconv包

```go
func ParseBool(str string) (value bool, err error)
func ParseInt(s string, base int, bitSize int) (i int64, err error)
func ParseFloat(s string, bitSize int) (f float64, err error)
func Atoi(s string) (i int, err error)
```

ParseInt：

返回字符串表示的整数值，接受正负号。

base指定进制（2到36），如果base为0，则会从字符串前置判断，"0x"是16进制，"0"是8进制，否则是10进制；

bitSize指定结果必须能无溢出赋值的整数类型，bitSize意义是保存数据用几个字节，用的字节小了那么就会有截断

**在将 String 类型转成 基本数据类型时，要确保 String 类型能够转成有效的数据，比如 我们可以**
**把 "123" , 转成一个整数，但是不能把 "hello" 转成一个整数，如果这样做，Golang 直接将其转成 0**

### 基本数据类型转字符串

```go
func Sprintf(format string, a ...interface{}) string
func Itoa(i int) string
```

Sprintf根据format参数生成格式化的字符串并返回该字符串。

### 基本数据之间的转换

1. Go中，数据类型的转换可以是从表示范围小-->表示范围大，也可以范围大--->范围小
2. 被转换的是变量存储的数据(即值)，变量本身的数据类型并没有变化

# 指针

1. 值类型，都有对应的指针类型， 形式为 *****数据类型，比如 int 的对应的指针就是 *int, float32
   对应的指针类型就是 *float32, 依次类推
2. 值类型包括:基本数据类型 **int** 系列**, float** 系列**, bool, string** 、数组和结构体 struct

## 值类型和引用类型

1. 值类型:基本数据类型 int 系列, float 系列, bool, string 、数组和结构体 struct
2. 引用类型:指针、slice 切片、map、管道 chan、interface 等都是引用类型
3. 变量直接存储值，内存通常在栈中分配
4. 引用类型:变量存储的是一个地址，这个地址对应的空间才真正存储数据(值)，内存通常在堆
   上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由 GC 来回收




英文slash  dot

字符串的相关操作

bytes 的相关操作

iota 是什么情况？看美女老师的笔记？

读取用户输入？readString

字符串的几种常用方法

三种分支结构？

数组的冒泡排序？

数组作为函数参数和返回值？是否是合理的？

随机数怎么产生？

切片作为函数参数和返回值？是否是合理的？

map作为函数参数和返回值？是否是合理的？、

复杂变量的是怎么声明的，声明是怎么取舍的？

复杂变量常用的操作是什么？

复杂变量如何组合到一起？组合在一起怎么使用？如何取值？如何循环等？

