反射具有强大的功能

* 程序检查其拥有的结构，尤其是类型
* 元编程的一种形式(更贴近底层的编程)
* 可以在运行时通过反射来分析一个结构体
* 检查其类型和变量(类型和取值)和方法
* 动态修改变量和调用方法
* 对于看不到源码的包尤其有用

# 反射获取类型和值

```go
package main

import (
	"fmt"
	"reflect"
)

type Human struct {
	name string
	age int
}

func (h *Human) GetName() string {
	return h.name
}

func (h *Human) SetName(name string)  {
	h.name = name
}

func getObjInfo(obj interface{})  {
	fType := reflect.TypeOf(obj)
	fmt.Println(fType)
	fValue := reflect.ValueOf(obj)
	fmt.Println(fValue)

}

func main() {

	h := Human{"jack", 23}
	getObjInfo(h)
}


```

# 反射获取属性信息

```go
package main

import (
	"fmt"
	"reflect"
)

type Human struct {
	Name string
	Age int
}

func (h *Human) GetName() string {
	return h.Name
}

func (h *Human) SetName(name string)  {
	h.Name = name
}

func getObjFields(obj interface{})  {
	oType := reflect.TypeOf(obj)
	oValue := reflect.ValueOf(obj)
	fieldsCount := oType.NumField()
	for i := 0; i < fieldsCount; i++ {
		// 调用Interface()之后jack就是字符串的jack，23就是int的23
		fValue := oValue.Field(i).Interface()
		structField := oType.Field(i)
		fmt.Println(structField.Name, structField.Type, fValue)
	}
}

func main() {

	h := Human{"jack", 23}
	getObjFields(h)
}


```

# 反射获取方法信息

```go
package main

import (
	"fmt"
	"reflect"
)

type Human struct {
	Name string
	Age int
}

func (h *Human) GetName() string {
	return h.Name
}

func (h *Human) SetName(name string)  {
	h.Name = name
}

func getObjMethods(obj interface{})  {
	oType := reflect.TypeOf(obj)
	for i := 0; i < oType.NumMethod(); i++ {
		method := oType.Method(i)
		// 方法的Type也叫方法的类型签名
		fmt.Println(method.Name, method.Type)
	}
}
func main() {

	h := Human{"jack", 23}
	getObjMethods(&h)
}


```

# 修改对象属性的值

```go
package main

import (
	"fmt"
	"reflect"
)

type Human struct {
	Name string
	Age int
}

func (h *Human) GetName() string {
	return h.Name
}

func (h *Human) SetName(name string)  {
	h.Name = name
}

func modifyFieldValue(objPtr interface{})  {
	// 地址的value
	oPtrValue := reflect.ValueOf(objPtr)
	// 有了地址就能取到里面的元素了
	oValue := oPtrValue.Elem()
	for i := 0; i < oValue.NumField(); i++ {
		fValue := oValue.Field(i)
		fKind := fValue.Kind()
		switch fKind {
		case reflect.String:
			fValue.SetString("pxo")
		case reflect.Int:
			fValue.SetInt(87)

		}
		}

	}



func main() {

	h := Human{"jack", 23}
	modifyFieldValue(&h)
	fmt.Println(h)
}


```

# 调用方法

```go
package main

import (
	"fmt"
	"reflect"
)

type Human struct {
	Name string
	Age int
}

func (h *Human) GetName() string {
	return h.Name
}

func (h *Human) SetName(name string)  {
	h.Name = name
}

func CallMethod(objPtr interface{})  {
	// 方法的值就是一堆代码指令
	oValue := reflect.ValueOf(objPtr)
	oType := reflect.TypeOf(objPtr)
	for i := 0; i < oType.NumMethod(); i++ {
		args := make([]reflect.Value, 0)
		// 方法的类型，就是方法的签名，可以获取参数等信息
		methodType := oType.Method(i).Type
		for j := 0; j < methodType.NumIn(); j++ {
			argkind := methodType.In(j).Kind()
			switch argkind {
			case reflect.String:
				args = append(args, reflect.ValueOf("我是中国的jack"))
			}
		}
		fValue := oValue.Method(i)
		fValue.Call(args)

	}

}



func main() {

	h := Human{"jack", 23}
	CallMethod(&h)
	fmt.Println(h)
}


```

