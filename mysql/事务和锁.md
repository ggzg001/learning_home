

```python
%load_ext sql
%sql mysql+pymysql://root@localhost/myemployees
```




    'Connected: root@myemployees'



# 事务

事务:事务由单独单元的一个或多个SQL语句组成，在这个单元中，每个MySQL语句是相互依赖的。而整个单独单元作为一个不可分割的整体，如果单元中某条SQL语句一旦执行失败或产生错误，整个单元将会回滚。所有受到影响的数据将返回到事物开始以前的状态;如果单元中的所有SQL语句均执行成功，则事物被顺利执行。(可以简单地理解为事务的sql操作先是在内存中"打草稿", 事务中的sql全部正确那么才会真正去执行所有的sql语句，在打草稿的演练过程中一旦发现有哪条语句执行失败所有的sql语句都不会真正执行)。

通过show engines;来查看mysql支持的存储引擎。

在mysql中用的最多的存储引擎有:innodb， myisam ,memory 等。其中innodb支持事务，而 myisam、memory等不支持事务


```python
%sql show engines;
```

     * mysql+pymysql://root@localhost/myemployees
    9 rows affected.





<table>
    <tr>
        <th>Engine</th>
        <th>Support</th>
        <th>Comment</th>
        <th>Transactions</th>
        <th>XA</th>
        <th>Savepoints</th>
    </tr>
    <tr>
        <td>ARCHIVE</td>
        <td>YES</td>
        <td>Archive storage engine</td>
        <td>NO</td>
        <td>NO</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>BLACKHOLE</td>
        <td>YES</td>
        <td>/dev/null storage engine (anything you write to it disappears)</td>
        <td>NO</td>
        <td>NO</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>MRG_MYISAM</td>
        <td>YES</td>
        <td>Collection of identical MyISAM tables</td>
        <td>NO</td>
        <td>NO</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>FEDERATED</td>
        <td>NO</td>
        <td>Federated MySQL storage engine</td>
        <td>None</td>
        <td>None</td>
        <td>None</td>
    </tr>
    <tr>
        <td>MyISAM</td>
        <td>YES</td>
        <td>MyISAM storage engine</td>
        <td>NO</td>
        <td>NO</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>PERFORMANCE_SCHEMA</td>
        <td>YES</td>
        <td>Performance Schema</td>
        <td>NO</td>
        <td>NO</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>InnoDB</td>
        <td>DEFAULT</td>
        <td>Supports transactions, row-level locking, and foreign keys</td>
        <td>YES</td>
        <td>YES</td>
        <td>YES</td>
    </tr>
    <tr>
        <td>MEMORY</td>
        <td>YES</td>
        <td>Hash based, stored in memory, useful for temporary tables</td>
        <td>NO</td>
        <td>NO</td>
        <td>NO</td>
    </tr>
    <tr>
        <td>CSV</td>
        <td>YES</td>
        <td>CSV storage engine</td>
        <td>NO</td>
        <td>NO</td>
        <td>NO</td>
    </tr>
</table>



# ACID

事务的ACID(acid)属性
1. 原子性(Atomicity)：
   原子性是指事务是一个不可分割的工作单位，事务中的操作要么
   都发生，要么都不发生。
2. 一致性(Consistency)：事务必须使数据库从一个一致性状态变换到另外一个一致性状态。一致性更多的是从现实世界的角度去看的。比如A有1000元,B有1000元，总共有2000元，一致性是说A转500给B，那么A是500，B是1500，两者和还是2000. 如果A是500，B还是1000，那么总共1500，丢失的500去哪了？这就不符合一致性。
3. 隔离性(Isolation)： 事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。隔离级别不同，这里的隔离性也就不同。事务比较重要的就是这里的隔离性
4. 持久性(Durability) ：持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影 响。比如说删除一条数据，一旦commit了，那么数据就被删了，无法恢复(正常情况是这样，当然也可以通过一些备份机制去恢复)


## 隔离级别

对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:
* 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的.(只读一次，读到是脏的数据)
* 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了.(重复读2次，读取的结果不一致)
* 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插 入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行.(重复读2次，读取的记录的数目不一致)

数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题.

一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱.

数据库提供的 4 种事务隔离级别:

|事务隔离级别|	脏读|	不可重复读	|幻读|
|---|---|---|---|
|读未提交（read-uncommitted）|	是	|是	|是|
|不可重复读（read-committed）|	否	|是	是|
|可重复读（repeatable-read）|	否	|否	|是|
|串行化（serializable）|	否|	否	|否|




```python

```
