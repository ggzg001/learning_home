# pycharm断点调试

1. F8 step over下一步,会把函数调用看做是一行代码直接执行   
2. 可以在console看到print打印的东西
3. F7 step into 单步执行，如果是函数,会进入函数内部

# __new__

`__new__` 就是创建一个空白的对象，并返回对象的引用给`__init__`,完成初始化工作。必须在`__new__` 里调用super,调用object的`__new__`, object的`__new__` 是一个静态方法，调用的时候必须手动传cls参数。单例模式就是重写`__new__`,

# 在类外给对象增加属性

在日常开发中，不推荐在类的外部给对象添加属性(如果在运行时，没找到属性会报错，这种就是属性的命名顺序的问题，不能把这个运行依赖顺序来弄)。对象有哪些属性，应该封装在类的内部。

```python
# 面向对象写单例类
class People:
    _instacne = None
    def __new__(cls, *args, **kwargs):
        if not cls._instacne:
            cls._instacne = super().__new__(cls)
        return cls._instacne

    def __init__(self, name):
        self.name = name

p1 = People("jack")
p2 = People("alex")
# 发现p1的name和p2 的name 是相同的, 这是所有程序都是一个实例的含义
print(p1.name, p2.name)
```

# 几个小tips

1. 全局变量最好不要修改，不可控性太高
2. 给开发完成的函数写文档注释
3. 对象.类属性  的方式不推荐使用，容易产生混淆, 避免困惑
4. 类方法的第一个参数是cls, 哪一个类去掉用，那么cls就是哪一个类
5. 列表不能循环删除，索引会跟着变，字典也不能在循环的时候删除，可以把key先保存在一个列表中
6. python中的函数名其实就是内存地址，通过内存地址可以进行代码块的调用
7. python的安装目录下lib是内置的模块，site_pacakges是安装的第三方模块

# 赋值、浅拷贝和深拷贝

* 赋值是将一个对象的地址赋值给一个变量，让变量指向该地址（旧瓶装旧酒）
* 浅拷贝也是拷贝，会创建新对象，只拷贝一层，所以如果拷贝的对象里又套有列表，那么此时需要注意
* 深拷贝：拷贝多层

# pycharm的几点技巧

1. 光标的位置可以看出 所在的条件
2. 重命名变量：refactor -> rename，选项有2个，一个是更改变量名和字符串，另一个是修改变量名

# 静态、类和实例方法

* 静态方法：既不需要访问实例属性也不需要访问类属性，静态方法一般通过类名. 的方式去调用，因为不需要创建对象
* 实例方法里需要访问实例属性，当然里面也可以使用类名. 访问类属性
* 类方法：只需要访问类的属性

# 设计模式

设计模式就是前人的总结，为了解决特定问题的成熟的解决方案，为了重用代码，方便别人理解，保证代码可靠性。

# 几种装饰器

函数的装饰器、类的装饰器和装饰类的装饰器

# __repr__ 和 __str__

1. str(obj)  要求必须实现__str__ 方法，必须返回字符串类型
2. repr 是 让对象 原形毕露，用于ipython调试
3. `__repr__`是`__str__`的备胎
4. %s 对应str, %r 对应repr
5. 一个类没有实现`__str__`, 那么就会去寻找继承父类的`__str__ `.注意这个父类不能是obejct, 如果是object，那么就会不会去obejct找`__str__`，而是在本类找`__repr__`

# hash

* 操作系统对内存的定位是准确而迅速的，也就是说给了虚拟内存地址，那么就能立马定位到这个内存空间，拿到里面的数据
* 字典的key会hash得到一个地址，然后把value存进去，所以字典寻址很快，不像连续数据结构一样需要遍历
* set的去重也是通过hash来完成的，如果hash的得到的值相同(hash并不是完全唯一的)，会进行二次hash(或者说进行值得比较，值不同就放另外的空间)
* hash(obj)  obj必须实现__hash__ 

# 包和模块

1. import 的时候会从sys.path 去寻找py文件的路径，可以借助`__file__`(可以查看py文件的完整路径)来添加查找路径
2. `sys.modules` 是一个字典，存储了所有文件的名字和内存地址的映射字典关系
3. import xx 的含义是创建一个名称空间，里面去加载xx的内容，然后增加xx来引用这个名称空间(也可以起别的名字来引用)，如果有一个login函数需要用到name变量，那么是从xx的名称空间去寻找，找不到就报错
4. import xx的时候会生成xx.pyc文件
5. from xx import login： 分两步，第一步是执行xx，第二步是增加一个引用：用login这个名字去引用xx空间的login
6. `__all__` 是一个列表，里面是字符串(为啥是字符串，因为变量的定义在`__all__` 下面)`__all__` 影响的是*，如果指名道姓地导入那就没办法约束了
7. 重新加载模块:`importlib.reload(xx)`
8. 运行一个文件的两种方式：import 和直接运行(以脚本的方式运行)
9. 如果仅仅是import不会出现循环导入，因为import一次，不会重复import，明明在这个模块里的内容却显示找不到，那么很可能出现循环导入
10. `import glance.api` 中`.`的左边永远是包
    1. 包的使用分为两个层面：导入模块和导入包。`from flask import Flask` 就是导入模块(比较简单，没太多需要注意的点)，`import flask`就是导入包，导入包想要可以使用包里的所有py文件，就需要组织`__init__.py`.我们自定义的包想要有良好的用户体验，就需要组织好`__init__.py`
    2. 包的绝对导入和相对导入：使用了相对导入，那么py文件只能被当做模块执行，不能当做脚本运行。使用相对导入比较简单，可以在包内随意导入函数。这里的绝对导入的意思是要想使用包的py文件的路径拼接绝对路径(参照sys.path)

# 项目目录结构

```
bin: start.py  
conf 
core：核心代码
db：数据库相关
lib：通用的模块
log
```



class B:

​	def __init__(self, cls):

​		self.a = cls()

​                Self.a()

B(A)  好多源码都是这么写的

只是暴露一个B就行，可以在实例A之前和之后干点事

我用这个类，站在用的角度

包：分为导入包和导入模块























