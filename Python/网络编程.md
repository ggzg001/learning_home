# TCP

![img](https://ws1.sinaimg.cn/large/006tNc79ly1g26ufwkgbbj30hs0jwgmu.jpg)

## TCP的三次握手

位码即tcp标志位,有6种标示:SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)。

Sequence number(顺序号码) Acknowledge number(确认号码)

用A来标识服务端, B来标识客户端.

1. A处于LISTEN状态，等待别人来连接。
2. B想要连接A,开始发报文了，syn=1以及产生随机seq number=12345678，发完之后B处于SYN_SENT状态
3. A过来一小段时间收到报文，状态置为SYN_RCVD, A从SYN=1知道，B想要建立联机。那么A就要做出回应，向B发送ack number=(主机B的seq+1),syn=1,ack=1,随机产生seq=87654321的包
4. 客户端B收到A的报文，检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，确认不误了。B还要发一次消息，ack number=(主机B的seq+1)以及ack=1,此时B的状态置为ESTABLISHED
5. 服务器A收到之后状态置为ESTABLISHED.

### 为啥需要三次握手

防止已经失效的连接报文再次发送到服务器。假设这样一种场景：客户端发的报文在网络中滞留的时间太久但仍存活，客户端迟迟收不到响应就会再发一次，如果是两次握手，那么这次可能连接建立成功。那么上一次滞留的报文如果到达服务器端，服务端依旧发确认消息，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

但是如果是三次握手，那么服务器发的确认消息我客户端可以check一下这个消息是不是已经失效了，如果是失效那么就什么也不回，此时服务器认为客户端不想建立连接了。

![img](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2590032753,2466318043&fm=173&app=49&f=JPEG?w=640&h=716&s=E7F239D247AFCCEA106594580300D072)

## TCP的四次挥手

服务端和服务器端都可以先断开连接。假设客户端先断开连接。

1. 客户端B发FIN=1, 序列号seq=u, 客户端状态置为FIN-WAIT-1状态
2. 服务器A收到报文，看到FIN=1就知道这是一个结束报文，回了一个确认ACK=1, ack=u+1,并且带上自己的序列号seq=v,表示我知道啦.服务端就进入了CLOSE-WAIT（关闭等待）状态.这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3. 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5. 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1。客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6. 服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，<font color="red">服务器结束TCP连接的时间要比客户端早一些。</font>

### 为什么先发出断开连接的一方在TIME_WAIT需要等待2MSL的时间

确保最后一次的ACK报文能正确到达对方，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。

<font color="red">先断开连接的会处于TIME_WAIT状态，占用端口不放。在socket编程中遇到这种问题，可以对socket进行设置，让其重用端口</font>

`sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)`

获取缓冲区大小: `sock.getsockopt(SOL_SOCKET, SO_SNDBUF)`

## TCP数据传输机制

### 超时重传

超时重传用来保证数据的可靠传输，每次发送数据包时，发送的数据报都有seq号，接收端收到数据后，会回复ack进行确认，表示某一seq 号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。

### **重传**

超时重传是发送端在傻等超时，然后触发重传;而快速重传则是接收端主动告诉发送端数据没收到，然后触发发送端重传。

### 流量控制

TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己 还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 滑动窗可以是提高TCP传输效率的一种机制

### 拥塞控制

滑动窗用来做流量控制。流量控制只关注发送端和接受端自身的状况，而没有考虑整个网络的通信情况。拥塞控制，则是基于整个网络来考虑的。考虑一下这 样的场景：某一时刻网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多 的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风 暴”，TCP这个协议就会拖垮整个网络。为此，TCP引入了拥塞控制策略。拥塞策略算法主要包括：慢启动，拥塞避免，拥塞发生，快速恢复。



# UDP

UDP不需要建立连接，但是服务器端也需要进行绑定，因为服务端也需要有一个端口进行通信。

`listen（3），这个3的意思是我连接着一个，后面还可以有三个排队的，也就是支持4个人的服务，但是后面三个要排队。`

udpserver:

```
import socket
udp_sk = socket.socket(type=socket.SOCK_DGRAM)   #创建一个服务器的套接字
udp_sk.bind(('127.0.0.1',9000))        #绑定服务器套接字
msg,addr = udp_sk.recvfrom(1024)
print(msg)
udp_sk.sendto(b'hi',addr)                 # 对话(接收与发送)
udp_sk.close()  
```

udpclient

```
import socket
ip_port=('127.0.0.1',9000)
udp_sk=socket.socket(type=socket.SOCK_DGRAM)
udp_sk.sendto(b'hello',ip_port)
back_msg,addr=udp_sk.recvfrom(1024)
print(back_msg.decode('utf-8'),addr)
```



# tcp缓冲区

每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区.

这些I/O缓冲区特性可整理如下：

1. I/O缓冲区在每个TCP套接字中单独存在；
2.  I/O缓冲区在创建套接字时自动生成；
3. 即使关闭套接字也会继续传送输出缓冲区中遗留的数据；
4. 关闭套接字将丢失输入缓冲区中的数据。

# socket

## 粘包

粘包现象出现的成因还是原始方式的一次性接收数据，比如recv(1024), 只接收固定长度的数据，一次性数据接收少了，下一次就会有上一次的内容，接收多了就可能接收到两次的数据。归根到底还是不知道应该接收多少长度的数据。

解决办法：

1. 发数据的时候把长度先发过去，然后让对方recv/send 这种间隙来把缓冲区的数据消耗掉。
2. struct 模块，不管你要发的东西是多少字节，我都可以打包成固定大小，那么接收端就可以按照双方协议约定取固定的字节长度的元信息。`struct.pack('i',111111), struct.unpack()[0]` 

***拆包的发生情况***

当发送端缓冲区的长度大于网卡的MTU时，tcp会将这次发送的数据拆成几个数据包发送出去。

tcp的可靠和非可靠：

tcp在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以tcp是可靠的

而udp发送数据，对端是不会返回确认信息的，因此不可靠。

**udp是面向报文的，意思就是每个消息是一个包，你接收端设置接收大小的时候，必须要比你发的这个包要大，不然一次接收不了就会报错误**。

对于上面的理解，可以先从表现形式的层面去理解，可以先不用深究。

```
1.TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。
    2.UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。
    3.tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头，实验略
udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y>x数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠

tcp的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。
```



```
用TCP协议发送时，由于TCP是数据流协议，因此不存在包大小的限制（暂不考虑缓冲区的大小），这是指在用send函数时，数据长度参数不受限制。而实际上，所指定的这段数据并不一定会一次性发送出去，如果这段数据比较长，会被分段发送，如果比较短，可能会等待和下一次数据一起发送。至于怎么分段，这是协议或者说是抽象的socket层帮忙做的事情
```

## 认证客户端合法性

server

```
from socket import *
import hmac,os

secret_key=b'xxx'
def conn_auth(conn):
    '''
    认证客户端链接
    :param conn:
    :return:
    '''
    print('开始验证新链接的合法性')
    msg=os.urandom(32)
    conn.sendall(msg)
    h=hmac.new(secret_key,msg)
    digest=h.digest()
    respone=conn.recv(len(digest))
    return hmac.compare_digest(respone,digest)

def data_handler(conn,bufsize=1024):
    if not conn_auth(conn):
        print('该链接不合法,关闭')
        conn.close()
        return
    print('链接合法,开始通信')
    while True:
        data=conn.recv(bufsize)
        if not data:break
        conn.sendall(data.upper())

def server_handler(ip_port,bufsize,backlog=5):
    '''
    只处理链接
    :param ip_port:
    :return:
    '''
    tcp_socket_server=socket(AF_INET,SOCK_STREAM)
    tcp_socket_server.bind(ip_port)
    tcp_socket_server.listen(backlog)
    while True:
        conn,addr=tcp_socket_server.accept()
        print('新连接[%s:%s]' %(addr[0],addr[1]))
        data_handler(conn,bufsize)

if __name__ == '__main__':
    ip_port=('127.0.0.1',9999)
    bufsize=1024
    server_handler(ip_port,bufsize)
```

客户端：

```
from socket import *
import hmac,os

secret_key=b'xxx'
def conn_auth(conn):
    '''
    验证客户端到服务器的链接
    :param conn:
    :return:
    '''
    msg=conn.recv(32)
    h=hmac.new(secret_key,msg)
    digest=h.digest()
    conn.sendall(digest)

def client_handler(ip_port,bufsize=1024):
    tcp_socket_client=socket(AF_INET,SOCK_STREAM)
    tcp_socket_client.connect(ip_port)

    conn_auth(tcp_socket_client)

    while True:
        data=input('>>: ').strip()
        if not data:continue
        if data == 'quit':break

        tcp_socket_client.sendall(data.encode('utf-8'))
        respone=tcp_socket_client.recv(bufsize)
        print(respone.decode('utf-8'))
    tcp_socket_client.close()

if __name__ == '__main__':
    ip_port=('127.0.0.1',9999)
    bufsize=1024
    client_handler(ip_port,bufsize)
```

## socketserver

保持清晰的思路，这个需要完成什么事，这个事分几个阶段。基于tcp的套接字，关键就是两个循环，一个链接循环，一个通信循环。

socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题）

查找属性的顺序：ThreadingTCPServer->ThreadingMixIn->TCPServer->BaseServer

实例化得到server，先找ThreadMinxIn中的__init__方法，发现没有init方法，然后找类ThreadingTCPServer的__init__,在TCPServer中找到，在里面创建了socket对象，进而执行server_bind（相当于bind）,server_active（点进去看执行了listen）
找server下的serve_forever,在BaseServer中找到，进而执行self._handle_request_noblock()，该方法同样是在BaseServer中
执行self._handle_request_noblock()进而执行request, client_address = self.get_request()（就是TCPServer中的self.socket.accept()），然后执行self.process_request(request, client_address)
在ThreadingMixIn中找到process_request，开启多线程应对并发(这里可以很好地去理解mixin的含义和用法)，进而执行process_request_thread，执行self.finish_request(request, client_address)
上述四部分完成了链接循环，本部分开始进入处理通讯部分，在BaseServer中找到finish_request,触发我们自己定义的类的实例化，去找__init__方法，而我们自己定义的类没有该方法，则去它的父类也就是BaseRequestHandler中找....
源码分析总结：

基于tcp的socketserver我们自己定义的类中的

　　self.server即套接字对象
　　self.request即一个链接
　　self.client_address即客户端地址
基于udp的socketserver我们自己定义的类中的

　　self.request是一个元组（第一个元素是客户端发来的数据，第二部分是服务端的udp套接字对象），如(b'adsf', <socket.socket fd=200, family=AddressFamily.AF_INET, type=SocketKind.SOCK_DGRAM, proto=0, laddr=('127.0.0.1', 8080)>)
　　self.client_address即客户端地址

![425762-20151226114322968-1230975336](https://ws4.sinaimg.cn/large/006tNc79ly1g274ynzavbj31fb0u0nbu.jpg)