## all和any

如果可迭代的对象的所有元素全部非空（或者空迭代对象），就返回True。这个函数主要用来判断列表、元组、字典等对象是否有空元素，比如有10000个元素的列表，如果没有提供此函数，需要使用循环来实现，那么计算速度会比较慢。这个函数的等同下面代码的功能：

```python
def all(iterable):
    for element in iterable:
        if not element:
            return False
    return True
```

any() 函数用于判断给定的可迭代参数 iterable 是否全部为 False，则返回 False，如果有一个为 True，则返回 True.这个函数的等同下面代码的功能：

```python
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
```

## bytes和bytesarray

bytearray() 函数返回新字节数组，数组里的元素可变，且每个元素的值在0至255之间。bytes()函数是Python 3中增加的内置函数，语法、参数与bytearray() 一样，只是返回的新字节数组不可变。它是 bytearray() 的不可变版本。两者都可以转换成字符串，尤其是bytesarray, 可以对字节进行修改并decode成字符串。

## callable

检查对象object是否可调用。如果返回True，object仍然可能调用失败；但如果返回False，调用对象ojbect绝对不会成功。

**注意**：类是可调用的，而类的实例实现了__call__()方法才可调用。

## locals、globals和vars

得到的都是字典，用在函数里面locals得到的是当前函数的参数和在函数里声明的变量。

[globals()](https://docs.python.org/3.5/library/functions.html#globals)

返回当前全局符号表, 通常在是返回当前模块下的全局符号表, 比如全局内建的函数,以及模块里的全局符号(定义声明的变量,类, 实例等), 在函数或者类方法中, globals()返回的模块符号表是其所在模块, 而不是调用模块.

[locals()](https://docs.python.org/3.5/library/functions.html#locals) 

更新并以字典形式返回当前局部符号表. 自由变量由函数块的locals() 返回, 而不会由 class 块来返回. 需要注意的是, locals() 字典不应该被修改; 在解释器中对修改行为可能对 local 值或者自由变量无效.

[vars()](https://docs.python.org/3.5/library/functions.html#vars) 

返回 __dict__ 属性, 比如模块, 类, 实例, 或者其他 带有 __dict__ 属性的 object.比如模块和实例拥有可更新的 __dict__ 属性;然而其他 objects 可能会对 __dict__ 属性的写操作限制(例如 类使用 dictproxy 阻止直接对字典更新).vars() 如果不传参数, 那么作用与 locals() 一样. 需要注意的是, locals 字典只在读操作时使用, 因为对 locals 的更新会被忽略.但是对vars的<font color="red">更新操作是有效的</font>.

## sorted和reversed

对于`Python`内置函数`sorted()`，先拿来跟list（列表）中的成员`list.sort()`进行下对比。在本质上，list的排序和内建函数sorted的排序是差不多的，连参数都基本上是一样的。
主要的区别在于，`list.sort()`是对已经存在的列表进行操作，进而可以改变进行操作的列表。而内建函数`sorted`返回的是一个新的list，而不是在原来的基础上进行的操作.

有时候，我们要处理的数据内的元素不是一维的，而是二维的甚至是多维的，那要怎么进行排序呢？这时候，`sorted()`函数内的`key`参数就派上用场了！从帮助信息上可以了解到，`key`参数可传入一个自定义函数。那么，该如何使用呢？让我们看看如下代码：

```python
>>>l=[('a', 1), ('b', 2), ('c', 6), ('d', 4), ('e', 3)]
>>>sorted(l, key=lambda x:x[0])
Out[39]: [('a', 1), ('b', 2), ('c', 6), ('d', 4), ('e', 3)]
>>>sorted(l, key=lambda x:x[0], reverse=True)
Out[40]: [('e', 3), ('d', 4), ('c', 6), ('b', 2), ('a', 1)]
>>>sorted(l, key=lambda x:x[1])
Out[41]: [('a', 1), ('b', 2), ('e', 3), ('d', 4), ('c', 6)]
>>>sorted(l, key=lambda x:x[1], reverse=True)
Out[42]: [('c', 6), ('d', 4), ('e', 3), ('b', 2), ('a', 1)]
```

```python
In [46]: dic
Out[46]: {1: 'a', 3: 'b', 2: 'v'}

In [47]: sorted(dic.items(),key=lambda x:x[0])
Out[47]: [(1, 'a'), (2, 'v'), (3, 'b')]

In [48]: dict(sorted(dic.items(),key=lambda x:x[0]))
Out[48]: {1: 'a', 2: 'v', 3: 'b'}
```

* sorted返回的列表
* reversed 函数返回一个反转的迭代器。(其实revsersed是一个类，不是一个函数)

## filter、map和reduce

方法原型分别是:

filter(function, sequence): 返回可迭代对象

map(function, sequence,[sequence])：返回可迭代对象.function中的参数值不一定是一个x，也可以是x和y，甚至多个；后面的iterable表示需要参与function运算中的参数值，有几个参数值就传入几个iterable

reduce(function, sequence, starting_value)：对sequence中的item顺序迭代调用function，如果有starting_value，还可以作为初始值调用。<font color="red">function接收的参数个数只能为2，先把sequence中第一个值和第二个值当参数传给function，再把function的返回值和第三个值当参数传给function，然后只返回一个结果。</font>

综合：

```python
# [{'number': 4}, {'number': 5}, {'number': 6}]
a = map(lambda x: dict(zip(['number'], [x])),filter(lambda x: x > 3, [1,2,3,4,5,6]))
```

三者的意义：filter 是做筛选，map是做映射，reduce是聚合，filter和map可以结合使用(返回值参数值正好都需要时可迭代类型)

## zip

矩阵的行列转换：

```python
a = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(zip(*a))  输出结果是：[(1, 4, 7), (2, 5, 8), (3, 6, 9)]
print(map(list,zip(*a))) 输出结果是：[[1, 4, 7], [2, 5, 8], [3, 6, 9]]
```

## repr

原封不动地输出，引号和转义字符都不起作用。

## exec、eval和compile

* eval只接受一个表达式，exec可以接受一个具有Python语句的代码块：loops，try：except :,类和函数/方法定义等
* eval返回给定表达式的值，而exec忽略来自其代码的返回值，并始终返回None
* compile(source, '', mode)  mode分为eval和exec，另外如果source有内容，那么第二个参数可以为空，第二个参数表示代码来源。
* exec和eval都接受2个额外的位置参数 – 全局变量和局部变量 – 它们是代码看到的全局和局部变量范围。执行的时候从这里面取，执行生成的变量也放在这里面。



