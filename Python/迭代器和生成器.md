## next的参数

除了可以`StopIteration` 用来指示迭代的结尾，还可以通过next的第二个参数来标识迭代结束

```python
with open('/etc/passwd') as f:
    while True:
        line = next(f, None)
        if line is None:
            break
        print(line, end='')
```

## 代理迭代

构建了一个自定义容器对象，里面包含有列表、元组或其他可迭代对象。 想直接在你的这个新容器对象上执行迭代操作。

实际上你只需要定义一个 `__iter__()` 方法，将迭代操作代理到容器内部的对象上去。

```python
class Node(object):
    def __init__(self, value):
        self._value = value
        self._children = []

    def add_child(self, node):
        self._children.append(node)

    def __repr__(self):
        return str(self._value)

    def __iter__(self):
        return iter(self._children)

if __name__ == '__main__':
    root = Node(1)
    root.add_child(Node(2))
    root.add_child(Node(2))
    for c in root:
        print(c)
```

Python的迭代器协议需要 `__iter__()` 方法返回一个实现了 `__next__()` 方法的迭代器对象。

只要实现`__iter__` 就是可迭代的，同时实现`__iter__`和`__next__`才是迭代器。

```
from collections import Iterable, Iterator
```

## 新的迭代模式：生成器

一个函数中需要有一个 `yield` 语句即可将其转换为一个生成器。 跟普通函数不同的是，生成器只能用于迭代操作。

## 实现迭代器协议

在一个对象上实现迭代最简单的方式是使用一个生成器函数。用于替代`__iter__`和`__next__`.

迭代器必须在迭代处理过程中维护大量的状态信息。 坦白来讲，没人愿意写这么晦涩的代码。将你的迭代器定义为一个生成器后一切迎刃而解。

```
class Node:
    def __init__(self, value):
        self._value = value
        self._children = []

    def __repr__(self):
        return 'Node({!r})'.format(self._value)

    def add_child(self, node):
        self._children.append(node)

    def __iter__(self):
        return iter(self._children)

    def depth_first(self):
        yield self
        for c in self:
            yield from c.depth_first()

# Example
if __name__ == '__main__':
    root = Node(0)
    child1 = Node(1)
    child2 = Node(2)
    root.add_child(child1)
    root.add_child(child2)
    child1.add_child(Node(3))
    child1.add_child(Node(4))
    child2.add_child(Node(5))

    for ch in root.depth_first():
        print(ch)
    # Outputs Node(0), Node(1), Node(3), Node(4), Node(2), Node(5)
```

## 反向迭代

实现了 `__reversed__()` 的特殊方法时才能生效。

## 带有外部状态的生成器函数

如果你想让你的生成器暴露外部状态给用户， 别忘了你可以简单的将它实现为一个类，然后把生成器函数放到 `__iter__()` 方法中过去。

```
from collections import deque

class linehistory:
    def __init__(self, lines, histlen=3):
        self.lines = lines
        self.history = deque(maxlen=histlen)

    def __iter__(self):
        for lineno, line in enumerate(self.lines, 1):
            self.history.append((lineno, line))
            yield line

    def clear(self):
        self.history.clear()
```

为了使用这个类，你可以将它当做是一个普通的生成器函数。 然而，由于可以创建一个实例对象，于是你可以访问内部属性值， 比如 `history` 属性或者是 `clear()` 方法。代码示例如下：

```
with open('somefile.txt') as f:
    lines = linehistory(f)
    for line in lines:
        if 'python' in line:
            for lineno, hline in lines.history:
                print('{}:{}'.format(lineno, hline), end='')
```

## 迭代器切片

```
def count(n):
    while True:
        yield n
        n += 1

c = count(0)
# 想要取迭代的第10到20个元素分别是什么
from itertools import islice
for x in islice(c, 10, 20):
    print(x)
```

迭代器和生成器不能使用标准的切片操作，因为它们的长度事先我们并不知道(并且也没有实现索引)。 函数 `islice()` 返回一个可以生成指定元素的迭代器，它通过遍历并丢弃直到切片开始索引位置的所有元素。 然后才开始一个个的返回元素，并直到切片结束索引位置。

这里要着重强调的一点是 `islice()` 会消耗掉传入的迭代器中的数据。 必须考虑到迭代器是不可逆的这个事实。 

## 跳过可迭代对象的开始部分

遍历一个可迭代对象，但是它开始的某些元素你并不感兴趣，想跳过它们.

`itertools.dropwhile()` 函数。使用时，你给它传递一个函数对象和一个可迭代对象。 它会返回一个迭代器对象，丢弃原有序列中直到函数返回False之前的所有元素，然后返回后面所有元素。

```
from itertools import dropwhile
with open('/etc/passwd') as f:
    for line in dropwhile(lambda line: line.startswith('#'), f):
        print(line, end='')
```

可以跳过开始部分的注释行，但是同样也会跳过文件中其他所有的注释行

```
with open('/etc/passwd') as f:
    lines = (line for line in f if not line.startswith('#'))
    for line in lines:
        print(line, end='')
```

```python
from itertools import filterfalse

with open("a.txt") as f:
    s = filterfalse(lambda x: x.startswith("#"), f)
    for line in s:
        print(line.strip())
```

## 排列组合的迭代

### itertools.permutations() 

它接受一个集合并产生一个元组序列，每个元组由集合中所有元素的一个可能排列组成。 也就是说通过打乱集合中元素排列顺序生成一个元组

```python
In [33]: from itertools import permutations

In [34]: items = ['a','b','c']

In [36]: for p in permutations(items):
    ...:     print(p)
    ...:
    ...:
('a', 'b', 'c')
('a', 'c', 'b')
('b', 'a', 'c')
('b', 'c', 'a')
('c', 'a', 'b')
('c', 'b', 'a')
```

### itertools.combinations()

```python
In [38]: from itertools import combinations

In [39]: for p in combinations(items, 2):
    ...:     print(p)
    ...:
('a', 'b')
('a', 'c')
('b', 'c')

In [40]: for p in permutations(items, 2):
    ...:     print(p)
    ...:
    ...:
('a', 'b')
('a', 'c')
('b', 'a')
('b', 'c')
('c', 'a')
('c', 'b')
```

对于 `combinations()` 来讲，元素的顺序已经不重要了。 也就是说，组合 `('a', 'b')` 跟 `('b', 'a')` 其实是一样的(最终只会输出其中一个)

### itertools.combinations_with_replacement()

在计算组合的时候，一旦元素被选取就会从候选中剔除掉(比如如果元素’a’已经被选取了，那么接下来就不会再考虑它了)。 而函数 `itertools.combinations_with_replacement()` 允许同一个元素被选择多次

## 同时迭代多个序列

zip系列：

```
In [41]: a = [1, 2, 3]

In [42]: b = ['w', 'x', 'y', 'z']

In [43]: list(zip(a, b))
Out[43]: [(1, 'w'), (2, 'x'), (3, 'y')]

In [44]: from itertools import zip_longest

In [45]: list(zip_longest(a, b))
Out[45]: [(1, 'w'), (2, 'x'), (3, 'y'), (None, 'z')]

In [46]: list(zip_longest(a, b, fillvalue=0))
Out[46]: [(1, 'w'), (2, 'x'), (3, 'y'), (0, 'z')]
```

想成对处理数据的时候 `zip()` 函数是很有用的。 比如，假设你头列表和一个值列表，就像下面这样

```
headers = ['name', 'shares', 'price']
values = ['ACME', 100, 490.1]
s = dict(zip(headers,values))
```

## 不同集合上元素的迭代

想在多个对象执行相同的操作，但是这些对象在不同的容器中，你希望代码在不失可读性的情况下避免写重复的循环。

`itertools.chain()` 方法可以用来简化这个任务。 它接受一个可迭代对象列表作为输入，并返回一个迭代器，有效的屏蔽掉在多个容器中迭代细节。

使用 `chain()` 的一个常见场景是当你想对不同的集合中所有元素执行某些操作的时候。这种解决方案要比像下面这样使用两个单独的循环更加优雅。

`itertools.chain()` 接受一个或多个可迭代对象作为输入参数。 然后创建一个迭代器，依次连续的返回每个可迭代对象中的元素。 这种方式要比先将序列合并再迭代要高效的多。

`a + b` 操作会创建一个全新的序列并要求a和b的类型一致。 `chian()` 不会有这一步，所以如果输入序列非常大的时候会很省内存。 并且当可迭代对象类型不一样的时候 `chain()`同样可以很好的工作。

## 展开嵌套的序列

将一个多层嵌套的序列展开成一个单层列表

```
from collections import Iterable

def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            yield from flatten(x)
        else:
            yield x

items = [1, 2, [3, 4, [5, 6], 7], 8]
# Produces 1 2 3 4 5 6 7 8
for x in flatten(items):
    print(x)
```

语句 `yield from` 在你想在生成器中调用其他生成器作为子例程的时候非常有用。 如果你不使用它的话，那么就必须写额外的 `for` 循环了。比如：

```
def flatten(items, ignore_types=(str, bytes)):
    for x in items:
        if isinstance(x, Iterable) and not isinstance(x, ignore_types):
            for i in flatten(x):
                yield i
        else:
            yield x
```

## 迭代器代替while无限循环

`iter` 函数一个鲜为人知的特性是它接受一个可选的 `callable` 对象和一个标记(结尾)值作为输入参数。 当以这种方式使用的时候，它会创建一个迭代器， 这个迭代器会不断调用 `callable` 对象直到返回值和标记值相等为止。

这种特殊的方法对于一些特定的会被重复调用的函数很有效果，比如涉及到I/O调用的函数。 举例来讲，如果你想从套接字或文件中以数据块的方式读取数据，通常你得要不断重复的执行 `read()`或 `recv()` ， 并在后面紧跟一个文件结尾测试来决定是否终止。这节中的方案使用一个简单的 `iter()` 调用就可以将两者结合起来了。

```
CHUNKSIZE = 8192

def reader(s):
    while True:
        data = s.recv(CHUNKSIZE)
        if data == b'':
            break
        process_data(data)
```

这种代码通常可以使用 `iter()` 来代替，如下所示：

```
def reader2(s):
    for chunk in iter(lambda: s.recv(CHUNKSIZE), b''):
        pass
        # process_data(data)
```