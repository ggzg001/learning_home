并发是软件层面的，并行看你有没有钱

正常结束有返回值

init 进程是所有进程的父进程

回收它的特殊值

与时间相关的错误：线程同步

对共享资源的访问一般采用加锁的方式

协程并发是为了提高效率，线程是为了抢cpu

go在语言层面实现了协程，不需要程序员去手动设计代码

常称为 go 程

Gosched 主动 让出时间片

还没来得及注册和return的关系

goexit ： 退出当前函数的协程

上一次设置的cpu数

Channel 是对共享内存的封装

无缓冲channel 需要双方都准备好

需要生成列表的时候使用列表解析

因为睡了一段时间，所以cpu都会易主

屏幕在linux系统中对应一个stdout文件

无缓冲通道在数据没有到达的时候回阻塞，感觉这一点是锁的特性

睡眠是主go程读

无缓冲channel: 一旦数据写进去，就要被读走，不然会阻塞。同步

有缓冲channel:存储至容量上限才会阻塞。 异步  消息发出去就走了，什么时候拿你随意

关闭channel，那么接受者也能感知到发送者没有数据要发送了

已经关闭的可以读数据但是不能写数据

无缓冲channel关闭也能读，读到一个值0,读有缓冲数据，读完数据后继续读，读到的值是零值

for range 读数据可以捕获关闭的情况，相当于ok的情况

双向channel可以转为单向channel(声明就行)，反之不行

声明一个双向的，然后在类型上加以限定(会隐式转换)

缓冲区：并发、解耦、缓冲



## `__init__`不是构造方法

`__new__`是构造方法(必须返回对象，没有对象返回则`__init__`不会被)，`__init__` 完成初始化操作(不能有return, 否则抛出TypeError)。

* 想要控制类的创建，可以重写`__new__`方法，控制实例初始化使用`__init__`.
* 一般不需要覆盖`__new__`方法，但当子类继承不可变类型时往往需要覆盖`__new__`方法。
* 当需要重写`__new__`和`__init__`时，这两个方法的参数需要保持一致，不一致会抛出异常。

### 重写`__new__`的几种场景

* 类继承不可变类型
* 实现工厂模式、单利模式或元类编程(控制对象的创建)
* 

工厂模式：

```python
import abc


class Shape(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def __init__(self):
        pass

    @abc.abstractmethod
    def draw(self):
        pass


class Square(Shape):
    def __init__(self):
        self.name = "square"

    def draw(self):
        print("I am drawing {}".format(self.name))


class Rectangle(Shape):
    def __init__(self):
        self.name = "rectangle"

    def draw(self):
        print("I am drawing {}".format(self.name))


class ShapeFactory:
    shapes = {"square": Square, "rectangle": Rectangle}
    def __new__(cls, name):
        if name in cls.shapes:
            return cls.shapes[name]()
        else:
            return Shape()

ShapeFactory("square").draw()
```



## LGEB

local、global、enclosing functions locals和build-in.

cpython中，只要出现赋值语句(或者称为名字绑定)，那么这个名字就会当做局部变量修改(全局环境的局部就是其本身)

```python
def foo():
    a = 1
    def bar():
        b = a * 2
        a = b + 1
        print(a)
    return bar
foo()()
"""
Traceback (most recent call last):
  File "/Users/guwanhua/git/castle/tricks/entrance/进程/test.py", line 128, in <module>
    foo()()
  File "/Users/guwanhua/git/castle/tricks/entrance/进程/test.py", line 123, in bar
    b = a * 2
UnboundLocalError: local variable 'a' referenced before assignment
"""
```

闭包中国，在编译字节码的时候，因为出现a = b +1，会把a当做局部变量看待，真正执行时先执行b = a * 2,此时局部变量a还不存在。可以使用nolocal来解决。

## 描述符

1. 自定义的类和对象可以动态地增加属性
2. 内置类型不能动态增加属性

描述符property本质上是数据描述符，更确切地说是类。

使用property可以更好地进行属性访问，如控制属性访问权限，把某个属性设置为只读。

```python
class A:
    def __init__(self):
        self._name = "jack"

    @property
    def name(self):
        return self._name

a = A()
a.name = "jack"
# 没有设置
"""
Traceback (most recent call last):
  File "/Users/guwanhua/git/castle/tricks/entrance/进程/test.py", line 128, in <module>
    a.name = "jack"
AttributeError: can't set attribute
"""
```

## 区分`__getattr__`和`__getattribute__`

均可作为对<font color="red">实例属性</font>的获取和拦截。__getattr__适用于未定义的属性，getattribute适用于所有属性的访问。实例对类属性的访问不会触发`__getattr__`和`__getattribute__`的访问。

`__getattr__`被调用的时机：

实例属性不在实例或基类以及祖先类的`__dict__`中；

触发AttributeError异常时(`__getattribute__`引发的或者property的get方法引发的异常)

当`__getattr__`和`__getattribute__`同时定义时，要么在`__getattribute__`显式地调用，要么是抛出AttributeError，否则`__getattr__`永远不会被调用.

### 重写注意事项

1.避免无穷递归

```python
class A(object):
    def __init__(self):
        self.name = "jack"

    def __getattribute__(self, name):
        try:
          	# return super().__getattribute__(name)
            return self.__dict__[name]
        except KeyError:
            return "default"
    
a = A()
print(a.name)
"""
Traceback (most recent call last):
  File "/Users/guwanhua/git/castle/tricks/entrance/进程/test.py", line 129, in <module>
    print(a.name)
  File "/Users/guwanhua/git/castle/tricks/entrance/进程/test.py", line 125, in __getattribute__
    return self.__dict__[name]
  File "/Users/guwanhua/git/castle/tricks/entrance/进程/test.py", line 125, in __getattribute__
    return self.__dict__[name]
  File "/Users/guwanhua/git/castle/tricks/entrance/进程/test.py", line 125, in __getattribute__
    return self.__dict__[name]
  [Previous line repeated 329 more times]
RecursionError: maximum recursion depth exceeded while calling a Python object
"""
```

```python
class A(object):
    def __init__(self):
        self.name = "jack"

    def __getattr__(self, name):
        try:
            return self.__dict__[name]
        except KeyError:
            return "default"

a = A()
print(a.name)
print(a.age)
"""
jack
default
"""
```

2.hasattr调用的是`__getattr__`, `__getattr__` 默认返回的None会影响hasattr的判断。

```python
class A(object):
    def __init__(self):
        self.name = "jack"

    def __getattribute__(self, name):
        print("calling __getattribute__")
        # 会去调用__getattr__
        return super().__getattribute__(name)


    def __getattr__(self, item):
        print("calling __getattr__")
        if item == "name":
            return "name"
        elif item == "age":
            return "age"

a = A()
print(hasattr(a, "xxx"))
"""
calling __getattribute__
calling __getattr__
True
"""
```

"xxx"并不是a的属性，hasattr返回True.此时a.xxx的结果就是None.为了避免这种令人混淆的现象，`__getattr__`可以主动抛出异常AttributeError.

```python
class A(object):
    def __init__(self):
        self.name = "jack"

    def __getattribute__(self, name):
        print("calling __getattribute__")
        # 会去调用__getattr__
        return super().__getattribute__(name)


    def __getattr__(self, item):
        print("calling __getattr__")
        if item == "name":
            return "name"
        elif item == "age":
            return "age"
        else:
            raise AttributeError("unkown type {}".format(item))

a = A()
print(hasattr(a, "xxx"))
"""
calling __getattribute__
calling __getattr__
False
"""
```

3.property、getattribute和getattr三者调用关系

```python
class A:
    _c = "test"
    def __init__(self):
        self.x = None

    @property
    def a(self):
        print("a property")
        if self.x is None:
            print("return value")
            return "a"
        else:
            print("error occurrd")
            raise AttributeError

    @a.setter
    def a(self, value):
        self.x = value

    @a.deleter
    def a(self):
        del self.x

    def __getattribute__(self, name):
        print("calling __getattribute__")
        return super().__getattribute__(name)

    def __getattr__(self, name):
        print("calling __getattr__")
        return "b"

a1 = A()
print(a1.a)
print('===')
a1.x = 10
print(a1.a)
"""
calling __getattribute__
a property
calling __getattribute__
return value
a
===
calling __getattribute__
a property
calling __getattribute__
error occurrd
calling __getattr__
b

"""
```

getattribute会被调用，然后调用property，只有property抛出异常才轮到getattr.

## 掌握metaclass

元方法(元类中定义的方法)可以从元类或者类进行调用，实例不能进行调用。类方法可以从类和实例进行调用。

## 利用操作符重载中缀语法

python的pipe模块实现了中缀语法。

```python
import functools

class Pipe:
    def __init__(self, function):
        self.function = function
        functools.update_wrapper(self, function)

    def __ror__(self, other):
        return self.function(other)

    def __call__(self, *args, **kwargs):
        return Pipe(lambda x: self.function(x, *args, **kwargs))
```

pipe将可迭代的数据看成是流，类似于linux，pipe使用'|'传递数据流，并且定义了一系列的“流处理”函数用于接受并处理数据流，并最终再次输出数据流或者是将数据流归纳得到一个结果。

```python
In [43]: from pipe import *

In [44]: range(5)|add
Out[44]: 10
```

求偶数和需要使用到where，作用类似于内建函数filter，过滤出符合条件的元素：

```python
In [45]: range(5)|where(lambda x: x%2 == 0)|add
Out[45]: 6
```

```python
from pipe import *

def fib():
    a = b = 1
    yield a
    yield b
    while True:
        a, b = b, a + b
        yield b

print(fib() | where(lambda x: x % 2) | take_while(lambda x: x < 100) | as_list)
```

读取文件，统计文件中每个单词出现的次数，然后按照次数高低排序。

```python
from re import split
from pipe import *
 
with open(r'a.txt') as f:  
    print(f.read()  
        | Pipe(lambda x:split('\W+', x))  
        | Pipe(lambda x:(i for i in x if i.strip()))  
        | groupby(lambda x:x)  
        | select(lambda x:(x[0], (x[1] | count)))  
        | sort(key=lambda x:x[1], reverse=True)  
        )

```

## 熟悉迭代器协议

使用迭代的方式实现斐波那契数列，只需要维护x和y两个变量就行。

```
def dropwhile(predicate, iterable):
    # dropwhile(lambda x: x<5, [1,4,6,4,1]) --> 6 4 1
    iterable = iter(iterable)
    for x in iterable:
        if not predicate(x):
            yield x
            break
    for x in iterable:
        yield x
```

## 熟悉生成器



## 对象的管理和垃圾回收

循环引用消耗内存：

```python
class Leak:
    pass

while True:
    A = Leak()
    B = Leak()
    A.b = B
    B.a = A
    A = None
    B = None
```



```python
import gc

class Leak:
    pass

collected = gc.collect()
print("before", collected)
A = Leak()
B = Leak()
A.b = B
B.a = A
A = None
B = None
collected = gc.collect()
print("after", collected)
print(gc.garbage)
"""
before 0
after 4
[]
"""
```

gc模块可以跟踪对象的"入引用"和"出引用"，并找出复杂结构之间的循环引用，同时回收内存垃圾。



## 单元测试

`python -m unittest discover`



## pylint或flake8检查代码风格



## 发布包到pypi



## Cprofile



## 使用memory_profile分析内存

## 掌握循环优化的基本技巧

1. 减少循环内部的计算步骤

   ```python
   import math
   v1 = [1, 2, 3]
   def f():
       j = 0
       # for i in v1:
       #     d = math.sqrt(10)
       #     j += i * d
       d = math.sqrt(10)
       for i in v1:
           j += i * d
   ```

2. 把显式循环改为隐式循环(如计算，使用n*(n+1)/2)

3. 循环中尽量引用局部变量(查找局部变量的速度比查全局变量更快)

   ```python
   import math
   x = [10, 20, 30]
   def f(x):
       # for i in range(len(x)):
       #     x[i] = math.sin(x[i])
       loc_sin = math.sin
       for i in range(len(x)):
           x[i] = loc_sin(x[i])
   ```

4. 关注内层嵌套循环

   ```python
   v1 = [1, 2, 3]
   v2 = [4, 5, 6]
   def f():
       # for i in range(len(v1)):
       #     for j in range(len(v2)):
       #         x = v1[i] + v2[j]
       #         print(x)
       for i in range(len(v1)):
           v1i = v1[i]
           for j in range(len(v2)):
               x = v1i + v2[j]
               print(x)
   ```

