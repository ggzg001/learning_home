在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点.

# 适配器模式

定义一个包装类，用于包装不兼容接口的对象。

1. 包装类 = 适配器Adapter；
2. 被包装对象 = 适配者Adaptee = 被适配的类。

把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。

适配器模式的形式分为：类的适配器模式 & 对象的适配器模式。

## 解决的问题

原本由于接口不兼容而不能一起工作的那些类可以在一起工作。

## 使用步骤

直接写包装类或包装方法。

### 类适配器

```python
from  abc import abstractmethod,ABCMeta
class Payment(metaclass=ABCMeta):
    @abstractmethod
    def pay(self,money):
        raise NotImplementedError

class Alipay(Payment):
    def pay(self, money):
        print("支付宝支付%s元"%money)


class ApplePay(Payment):
    def pay(self, money):
        print("苹果支付%s元"%money)

# =========待适配器==========
class WechatPay:
    def huaqian(self,a,b):
        print("微信支付%s元" % (a + b))

# ==========类适配器===========
class RealWeChatPay(Payment,WechatPay):
    def pay(self,money):
        return self.huaqian(money,0)
```

类适配器使用的是多继承,  带来的问题是如果还有别的待适配器，那么久需要再添加对应的类适配器。

### 对象适配器

```python
from  abc import abstractmethod,ABCMeta
class Payment(metaclass=ABCMeta):
    @abstractmethod
    def pay(self,money):
        raise NotImplementedError

class Alipay(Payment):
    def pay(self, money):
        print("支付宝支付%s元"%money)


class ApplePay(Payment):
    def pay(self, money):
        print("苹果支付%s元"%money)

# =========待适配器==========
class WechatPay:
    def huaqian(self,a,b):
        print("微信支付%s元" % (a + b))
        
#===========对象适配器===========
class PavAdepter(Payment):
    def __init__(self,payment):
        self.payment = payment
        
    def pay(self,money):
        return self.payment.huaqian(money,0)
      
PavAdepter(WechatPay()).pay(100)
```

对象适配器采用的是组合。

## 优点

客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单 & 更直接。

## 缺点

不知道

# 代理模式

给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用。

## 解决的问题

防止**直接**访问目标对象给系统带来的不必要复杂性。

## 使用场景

- 远程代理：为远程的对象提供代理
- 虚代理：根据需求创建很大的对象，如经常看到的点击某张小图片之后才能构建大图片对象。
- 保护代理：控制对原始对象的访问，用于对象有不同访问权限时，比如只读不能写。

## 使用步骤

没啥特别的，唯一需要关注的一点是代理类和被代理类的方法应保持一致。

## 实例



```python
from abc import abstractmethod,ABCMeta

class Subject(metaclass=ABCMeta):
    @abstractmethod
    def get_content(self):
        pass
# 真实的对象
class RealSubject(Subject):
    def __init__(self,filename):
        self.filename = filename
        print("读取%s文件内容" % filename)
        f = open(filename)
        self.content = f.read()
        f.close()

    def get_content(self):
        return self.content

    def set_content(self, content):
        f = open(self.filename, 'w')
        f.write(content)
        f.close()


class ProxyA(Subject):
    def __init__(self, filename):
        self.subj = RealSubject(filename)

    def get_content(self):
        return self.subj.get_content()

class ProxyB(Subject):
    '''虚代理'''
    def __init__(self, filename):
        # 只保存文件名并未真实地去创建对象
        self.filename = filename
        self.subj = None

    def get_content(self):
        if not self.subj:  #if True 如果为空的时候，就去读取文本
            self.subj = RealSubject(self.filename)
        return self.subj.get_content()


class ProxyC(Subject):
    '''保护代理'''
    def __init__(self, filename):
        self.subj = RealSubject(filename)

    def get_content(self):
        return self.get_content()

    def set_content(self):
        raise PermissionError

    # 写一个set_content

b = ProxyB("abc.txt")
print(b.get_content())
```

## 优点

- 协调调用者和被调用者，降低了系统的耦合度
- 代理对象作为客户端和目标对象之间的中介，起到了保护目标对象的作用

## 缺点

- 由于在客户端和真实主题之间增加了代理对象，因此会造成请求的处理速度变慢；
- 实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。

# 组合模式

将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。比如说在windows系统中, 一个长方形，一个三角形，两个单独都能进行放大，如果把两者圈在一起，右键点击放大，那么圈在一起的这两个图形也会一并放大。

## 解决的问题

对root的操作会反映到整棵树。

## 使用步骤

* 定义抽象组件
* 定义叶子组件
* 定义复合组件

## 实例

```python
from abc import abstractmethod,ABCMeta
class Graphic(metaclass=ABCMeta):
    '''图形类'''
    @abstractmethod
    def draw(self):
        pass

    @abstractmethod
    def add(self,graphic):
        pass

    @abstractmethod
    def getchildren(self,graphic):
        pass

class Point(Graphic):
    '''点'''
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def draw(self):
        print(self)

    def add(self,graphic):
        raise TypeError

    def getchildren(self,graphic):
        raise TypeError

    def __str__(self):
        return '点(%s,%s)' %(self.x,self.y)

class Line(Graphic):
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2

    def draw(self):
        print(self)

    def add(self, graphic):
        raise TypeError

    def getchildren(self):
        raise TypeError

    def __str__(self):
        return "线段[%s, %s]" % (self.p1, self.p2)

class Picture(Graphic):
    def __init__(self):
        self.children = []

    def add(self,graphic):
        self.children.append(graphic)

    def getchildren(self, graphic):
        '''返回列表里面的孩子'''
        return self.children

    def draw(self):
        print('======复合图形======')
        for i in self.children:
            print('所有的孩子们',i)
            i.draw()
        print('======end=========')


pic1 = Picture()
pic1.add(Point(2,3))
pic1.add(Line(Point(1,2), Point(4,5)))
pic1.add(Line(Point(0,1), Point(2,1)))


pic2 = Picture()
pic2.add(Point(-2,-1))
pic2.add(Line(Point(0,0), Point(1,1)))

pic = Picture()
pic.add(pic1)
pic.add(pic2)

pic.draw()
```

## 优点

- 定义了包含基本对象和组合的类层次结构
- 简化客户端代码，即客户端可以一致地使用组合对象和单个对象
- 更容易增加新类型的组件

## 缺点

递归？

## 适用场景

- 表示对象的‘部分-整体’层次结构（特别是结构是递归的）
- 希望用户忽略组合对象与单个对象的不同，用户统一的使用组合结构中的所有对象

# 外观模式

定义了一个高层、统一的接口，外部与通过这个统一的接口对子系统中的一群接口进行访问。

通过创建一个统一的外观类，用来包装子系统中一个 / 多个复杂的类，客户端可通过调用外观类的方法来调用内部子系统中所有方法

![img](https://upload-images.jianshu.io/upload_images/944365-e9c6add7c4d0fdf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)

给个网站的导航例子：以前我需要在搜索栏逐个搜索网站地址；有了网站导航（用了外观模式）后，就方便很多了

## 解决的问题

- 实现客户类与子系统类的松耦合
- 降低原有系统的复杂度
- 提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。

## 使用步骤

就是增加一个类，这个类里封装外观需要包裹的组件。

## 实例

```python
class AlarmSensor:
   def run(self):
       print("Alarm Ring...")
class WaterSprinker:
   def run(self):
       print("Spray Water...")
class EmergencyDialer:
   def run(self):
       print("Dial 119...")
 
class EmergencyFacade:
   """
   外观类中封装了对子系统的操作
   """
   def __init__(self):
       self.alarm_sensor=AlarmSensor()
       self.water_sprinker=WaterSprinker()
       self.emergency_dialer=EmergencyDialer()
   def runAll(self):
       self.alarm_sensor.run()
       self.water_sprinker.run()
       self.emergency_dialer.run()
 
if __name__=="__main__":
   emergency_facade=EmergencyFacade()
   emergency_facade.runAll()
```

## 优点

- 降低了客户类与子系统类的耦合度，实现了子系统与客户之间的松耦合关系
- 外观模式对客户屏蔽了子系统组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单。

## 缺点

不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。





