# GIL

GIL并不是python的特性，而是Cpython的特性。

明确一点：<font color="red">保护不同的数据的安全，就应该加不同的锁</font>

在一个python的进程内，不仅有py文件的主线程和由该主线程开启的其他线程，还有解释器开启的垃圾回收等解释器级别的线程，总之，所有线程都运行在这一个进程内。

所有线程的任务，都需要将任务的代码当做参数传给解释器的代码去执行，即所有的线程要想运行自己的任务，首先需要解决的是能够访问到解释器的代码。python解释器代码这一块其实可以分为两个步骤：把代码编译成字节码；python虚拟机运行字节码。

![988061-20180926100512742-1573465285](https://ws2.sinaimg.cn/large/006tNc79ly1g2diwusdn4j30ma0d70tq.jpg)

上图没有体现python虚拟机的角色，如果GIL只是单纯的一把互斥锁还不够，因为如果我拿到GIL锁，不主动释放锁，别人就拿不到锁，也就拿不到执行权限。所以python虚拟机在这里做了一些事，它来控制，等程序运行一段时间之后就会让进来的线程把锁释放。

## 多线程还是多进程？

我们有四个任务需要处理，处理方式肯定是要玩出并发的效果，解决方案可以是：
	方案一：开启四个进程
	方案二：一个进程下，开启四个线程

**单核情况下，分析结果**: 
　　如果四个任务是计算密集型，没有多核来并行计算，方案一徒增了创建进程的开销，方案二胜
　　如果四个任务是I/O密集型，方案一创建进程的开销大，且进程的切换速度远不如线程，方案二胜

**多核情况下，分析结果**：
　　如果四个任务是计算密集型，多核意味着并行计算，在python中一个进程中同一时刻只有一个线程执行用不上多核，方案一胜
　　如果四个任务是I/O密集型，再多的核也解决不了I/O问题，方案二胜

结论：现在的计算机基本上都是多核，python对于计算密集型的任务开多线程的效率并不能带来多大性能上的提升，甚至不如串行(没有大量切换)，但是，对于IO密集型的任务效率还是有显著提升的。

对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。
在多线程环境中，Python 虚拟机按以下方式执行：
	a、设置 GIL；
	b、切换到一个线程去运行；
	c、运行指定数量的字节码指令或者线程主动让出控制(可以调用 		time.sleep(0))；
	d、把线程设置为睡眠状态；
	e、解锁 GIL；
	d、再次重复以上所有步骤。

## GIL和普通互斥锁



1. 100个线程去抢GIL锁，即抢执行权限
2. 肯定有一个线程先抢到GIL（暂且称为线程1），然后开始执行，一旦执行就会拿到lock.acquire()
3. 极有可能线程1还未运行完毕，就有另外一个线程2抢到GIL，然后开始运行，但线程2发现互斥锁lock还未被线程1释放，于是阻塞，被迫交出执行权限，即释放GIL
4. 直到线程1重新抢到GIL，开始从上次暂停的位置继续执行，直到正常释放互斥锁lock，然后其他的线程再重复2 3 4的过程 

# Threading



## 进程和线程存储区别

导入的模块、执行的python文件的文件所在位置、内置的函数、文件里面的这些代码、全局变量等等，然后线程里面有自己的堆栈（类似于一个列表，后进先出）和寄存器，里面存着自己线程的变量，操作（add）等等，占用的空间很小。

<font color="red">多个线程内部有自己的数据栈，数据不共享全局变量在多个线程之间是共享的</font>

## 线程创建

threading模块本身提供的一些方法：

```
threading.currentThread(): 返回当前的线程变量。
threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果
```

准确地说，主进程会等待所有线程运行完毕才会销毁进程空间。

子线程也可以使用join或设置成守护线程。

### 守护线程

**无论是进程还是线程，都遵循：守护xx会等待主xx运行完毕后被销毁。需要强调的是：运行完毕并非终止运行**

1. 对主进程来说，运行完毕指的是主进程代码运行完毕。主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收, 因为进程有隔离性）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束

2. 对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕。主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。<font color="red">因为主线程比较特殊，它的结束意味着整个进程的结束</font>，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束，因为进程执行结束是要回收资源的，所有必须确保你里面的非守护子线程全部执行完毕。



## 线程同步

### condition

有些复杂的问题互斥锁搞不定，啥复杂问题，你到时说呀。`Python`提供的`Condition`对象提供了对复杂线程同步问题的支持。`Condition`被称为条件变量，除了提供与`Lock`类似的`acquire`和`release`方法外，还提供了`wait`和`notify`方法。

先看一个互斥锁解决不了的场景，假设两个智能聊天机器人（小米的小爱和天猫的天猫精灵）对话：

```
天猫精灵：小爱同学

小爱：在

天猫精灵：我们来对古诗吧

小爱：好啊

天猫精灵：我住长江头

小爱：不聊了，再见
```

```python
import threading

class XiaoAi(threading.Thread):
    def __init__(self, lock):
        super().__init__(name="小爱")
        self.lock = lock

    def run(self):
        self.lock.acquire()
        print("{} : 在".format(self.name))
        self.lock.release()

        self.lock.acquire()
        print("{} : 好啊".format(self.name))
        self.lock.release()

class TianMao(threading.Thread):
    def __init__(self, lock):
        super().__init__(name="天猫精灵")
        self.lock = lock

    def run(self):
        self.lock.acquire()
        print("{} : 小爱同学".format(self.name))
        self.lock.release()

        self.lock.acquire()
        print("{} : 我们来对古诗吧".format(self.name))
        self.lock.release()

if __name__ == "__main__":
    lock = threading.Lock()
    xiaoai = XiaoAi(lock)
    tianmao = TianMao(lock)

    tianmao.start()
    xiaoai.start()
# 运行结果如下：
# 天猫精灵 : 小爱同学
# 天猫精灵 : 我们来对古诗吧
# 小爱 : 在
# 小爱 : 好啊
```

理论上应该A线程在等待中，B线程在干活，干活完毕之后通知A线程活干完了，B线程进入等待，而A线程得到了通知之后，不再继续等待，开始干活，看完之后通知B线程，如此循环，直到结束。

##### 迂回解决



```python
import threading

class XiaoAi(threading.Thread):
    def __init__(self, lock, active_user):
        super().__init__(name="小爱")
        self.lock = lock
        self.active_user = active_user

    def wait(self):
        while(1):
            self.lock.acquire()
            user = self.active_user[0]
            self.lock.release()
            if user == 1:
                break

    def notify(self):
        self.lock.acquire()
        self.active_user[0] = 0
        self.lock.release()

    def run(self):
        self.wait()
        print("{} : 在".format(self.name))
        self.notify()

        self.wait()
        print("{} : 好啊".format(self.name))
        self.notify()

class TianMao(threading.Thread):
    def __init__(self, lock, active_user):
        super().__init__(name="天猫精灵")
        self.lock = lock
        self.active_user = active_user

    def wait(self):
        while(1):
            self.lock.acquire()
            user = self.active_user[0]
            self.lock.release()
            if user == 0:
                break

    def notify(self):
        self.lock.acquire()
        self.active_user[0] = 1
        self.lock.release()


    def run(self):
        self.wait()
        print("{} : 小爱同学".format(self.name))
        self.notify()

        self.wait()
        print("{} : 我们来对古诗吧".format(self.name))
        self.notify()

if __name__ == "__main__":
    # 0表示天猫执行， 1表示小爱
    # 因为是面向对象的类，这个是作为参数传入，为了共享使用引用类型的数据结构，为了保证两个线程修改active_user之后,互相是可见的，所以传了一个List,而不是整数
    active_user = [0] 
    lock = threading.Lock()
    xiaoai = XiaoAi(lock, active_user)
    tianmao = TianMao(lock, active_user)

    tianmao.start()
    xiaoai.start()
# 运行结果如下：可得到预期结果
# 天猫精灵 : 小爱同学
# 天猫精灵 : 我们来对古诗吧
# 小爱 : 在
# 小爱 : 好啊
```

##### 条件变量解决

```
1. acquire([timeout])/release(): 调用关联的锁的相应方法。 
2. wait([timeout]): 调用这个方法将使线程进入Condition的等待池等待通知，并释放锁。使用前线程必须已获得锁定，否则将抛出异常。 
3. notify(): 调用这个方法将从等待池挑选一个线程并通知，收到通知的线程将自动调用
4. acquire()尝试获得锁定（进入锁定池）；其他线程仍然在等待池中。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。 
5. notifyAll(): 调用这个方法将通知等待池中所有的线程，这些线程都将进入锁定池尝试获得锁定。调用这个方法不会释放锁定。使用前线程必须已获得锁定，否则将抛出异常。
```

```python
from threading import Thread, Condition


class Tianmao(Thread):
    def __init__(self, name, cond):
        super().__init__()
        self.name = name
        self.cond = cond

    def run(self):
        self.cond.acquire()

        print("{} : 小爱同学".format(self.name))
        self.cond.notify()
        self.cond.wait()
        print("{} : 我们来对古诗吧".format(self.name))
        self.cond.notify()
        self.cond.wait()
        print("{} : 我住长江头".format(self.name))
        self.cond.notify()
        self.cond.wait()
        self.cond.release()


class Xiaoai(Thread):
    def __init__(self, name, cond):
        super().__init__()
        self.name = name
        self.cond = cond

    def run(self):
        self.cond.acquire()
        self.cond.wait()
        print("{} : 在".format(self.name))
        self.cond.notify()
        self.cond.wait()
        print("{} : 好啊".format(self.name))
        self.cond.notify()
        self.cond.wait()
        print("{} : 不聊了，再见".format(self.name))
        self.cond.notify()
        self.cond.release()


if __name__ == '__main__':
    cond = Condition()
    tianmao = Tianmao("天猫", cond)
    xiaoai = Xiaoai("小爱", cond)
    # 启动顺序有讲究，tianmao先启动会阻死
    xiaoai.start()
    tianmao.start()
```

##### condition源码

condition内部维持了一把递归锁(底层锁)和一个等待队列。

cond.acquire:  调用的就是底层锁的acquire, 一旦拿到这把锁，在别的线程调用cond.acquire就不行了。

cond.wait:  这个wait是分阶段的，可以理解为进入wait和离开wait的阶段(又称之为被notify的阶段)。

1. 进入wait: 必须有底层锁才能进入wait.创建一把互斥锁，在该线程内acquire，把该锁放到等待队列等待被release, 然后释放底层锁(别的线程可以运行了), 并对创建的互斥锁再次acquire，如果在队列的这把锁没有被release那么就会阻塞
2. 离开wait: notify的互斥锁被释放之后可以再次acquire成功，此时因为是被notify唤醒的，底层锁可能还在notify那个线程内，这时会去尝试获取底层锁。调用了notify的线程一般会进行wait释放掉底层锁，这样wait就会彻底离开往下进行我们的业务逻辑代码了。

cond.notify: 前面线程wait释放了底层锁，别的线程就能acquire之后进行notify的操作。从互斥锁队列中去release锁，让等待在这个锁的线程可以继续往下运行。一般notify之后都会进行wait

**总结一下:**

1. wait: 释放底层锁(可能就被抢走了)；阻塞等待上层锁被notify; 去抢底层锁, 只有离开wait就表示获得底层锁(<font color="red">所以wait不仅仅和notify进行通信，也和wait进行通信</font>)。
2. notify: release上层锁。

### 事件

线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。 对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在 初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行。

```python
import time
import random
from termcolor import colored
from threading import Thread, Event

def conn_mysql(e):
    count = 0
    while not e.is_set():
        if count > 5:
            print(colored("连了5次都没成功，我不连了", "red"))
            return
        e.wait(random.random())
        print(colored("网络暂时不通", "red"))
        count += 1
    print(colored('终于可以连了', 'blue'))

def check_net(e):
    for i in range(3):
        time.sleep(random.random())
    e.set()
    print(colored('网络通了，可以进行连接', 'green'))


if __name__ == '__main__':
    e = Event()
    t1 = Thread(target=check_net, args=(e, ))
    t2 = Thread(target=conn_mysql, args=(e, ))
    t1.start()
    t2.start()
```

### 互斥锁

### 递归锁

### 死锁

#### 现象：科学家吃面

```python
import time
from termcolor import colored
from threading import Thread, Lock

def eat1(noodle_lock, fork_lock):
    noodle_lock.acquire()
    print(colored("抢到面条了", "green"))
    time.sleep(0.2)
    fork_lock.acquire()
    print(colored("抢到叉子了", "green"))
    time.sleep(0.2)
    fork_lock.release()
    noodle_lock.release()

def eat2(noodle_lock, fork_lock):
    fork_lock.acquire()
    print(colored("抢到叉子了", "blue"))
    time.sleep(0.2)
    noodle_lock.acquire()
    print(colored("抢到面条了", "blue"))
    time.sleep(0.2)
    noodle_lock.release()
    fork_lock.release()

if __name__ == '__main__':
    noodle_lock = Lock()
    fork_lock = Lock()
    professor = Thread(target=eat1, args=(noodle_lock, fork_lock))
    student = Thread(target=eat2, args=(noodle_lock, fork_lock))
    professor.start()
    student.start()
```

#### 解决方案一

递归锁，整个程序用一把锁，锁的名称可以不一样，但都是指向同一个锁对象。

```python
import time
from termcolor import colored
from threading import Thread, RLock

def eat1(noodle_lock, fork_lock):
    noodle_lock.acquire()
    print(colored("抢到面条了", "green"))
    time.sleep(0.2)
    fork_lock.acquire()
    print(colored("抢到叉子了", "green"))
    time.sleep(0.2)
    fork_lock.release()
    noodle_lock.release()

def eat2(noodle_lock, fork_lock):
    fork_lock.acquire()
    print(colored("抢到叉子了", "blue"))
    time.sleep(0.2)
    noodle_lock.acquire()
    print(colored("抢到面条了", "blue"))
    time.sleep(0.2)
    noodle_lock.release()
    fork_lock.release()

if __name__ == '__main__':
    noodle_lock = fork_lock = RLock()
    professor = Thread(target=eat1, args=(noodle_lock, fork_lock))
    student = Thread(target=eat2, args=(noodle_lock, fork_lock))
    professor.start()
    student.start()
```



## 线程数据共享



## 线程池

早期的时候我们没有线程池，现在python提供了一个新的标准或者说内置的模块，这个模块里面提供了新的线程池和进程池，之前进程池是在multiprocessing里面的，现在这个在这个新的模块里面，他俩用法上是一样的。



```python
import time
from concurrent.futures import ThreadPoolExecutor

def func(i):
    print(i)
    time.sleep(1)
    return i

def callback(future):
    # <Future at 0x1033f2d30 state=finished returned int>
    print(future, future.result())


if __name__ == '__main__':
    pool = ThreadPoolExecutor(4)
    for i in range(10):
        # submit 没有callback 参数，但是可以手动add_done_callback
        t = pool.submit(func, i)
        t.add_done_callback(callback)
    pool.shutdown()
```

```python
import time
from concurrent.futures import ThreadPoolExecutor

def func(i):
    print(i)
    time.sleep(1)
    return i

def callback(future):
    # <Future at 0x1033f2d30 state=finished returned int>
    print(future, future.result())


if __name__ == '__main__':
    pool = ThreadPoolExecutor(2)
    gen = pool.map(func, [1, 2, 3, 4, 5])
    for res in gen:
        print(res)
```

map 包含了shutdown的功能，并且map运行的func只能传递一个参数，从gen取出数据的过程是瞬间完成，不需要阻塞。