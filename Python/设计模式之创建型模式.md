## 创建型模式

创建式模式就是用来研究如何更合理创建对象的，其实设计模式的要做的事就是约束，设计的出发点也是调用你代码的人可能是个"傻子"。

### 简单工厂模式

#### 解决的问题

将“类实例化的操作”与“使用对象的操作”分开，让使用者不用知道具体参数就可以实例化出所需要的“产品”类，从而避免了在客户端代码中显式指定，实现了解耦。

即使用者可直接消费产品而不需要知道其生产的细节

比如一个类的实例化构造方法需要的某个参数必须是utf8格式的，而另一个类的实例化却需要的gbk格式，那么那个"傻子"在调用我们写的代码的时候还得区分哪个传utf8格式的字符串另一个传gbk格式的吗？所以，最简单的方式，我们提供一个简单工厂函数，"傻子"直接调用这个工厂函数，传入想要创建的对象类型就行。

#### 使用步骤

- 创建**抽象产品类** & 定义具体产品的公共接口；
- 创建**具体产品类**（继承抽象产品类） & 定义生产的具体产品；
- 创建**工厂类**，通过创建静态方法根据传入不同参数从而创建不同具体产品类的实例；
- 傻子通过调用工厂类的静态方法，**传入不同参数**从而创建不同**具体产品类的实例**

#### 实例

```python
from abc import ABCMeta, abstractclassmethod

class Animal(object):
    @abstractclassmethod
    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        print('汪汪汪')

class Cat(Animal):
    def speak(self):
        print('喵喵喵')

class Factory(object):
    def create_animal(self, atype):
        if atype == 'cat':
            obj = Cat()
        elif atype == 'dog':
            obj = Dog()
        return obj
############## 使用  ####################
f = Factory()
animal = f.create_animal('cat')
animal.speak()
```

#### 优点

将创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建，实现了解耦；

#### 缺点

- 工厂类集中了所有实例（产品）的创建逻辑，一旦这个工厂不能正常工作，整个系统都会受到影响；
- 违背“开放 - 关闭原则”，一旦添加新产品就不得不修改工厂类的逻辑，这样就会造成工厂逻辑过于复杂。

简单工厂模式一般不推荐使用。

### 工厂方法模式

#### 解决的问题

产品比较少的情况，使用简单工厂模式比较合理。当产品很多，而且未来可能会更多的情况下，这时候可以考虑工厂方法模式。

#### 使用步骤

- 创建**抽象产品类** & 定义具体产品的公共接口；
- 创建**具体产品类**（继承抽象产品类） & 定义生产的具体产品；
- 创建**抽象工厂类** & 定义生产产品的公共接口
- 创建具体工厂类 & 创建具体的产品
- 傻子通过调用具体工厂类创建具体产品

#### 实例

```python
from abc import ABCMeta, abstractclassmethod

# 抽象产品类
class CPU(metaclass=ABCMeta):
    @abstractclassmethod
    def run(self):
        pass

# 具体产品类
class IntelCpu(CPU):
    def run(self):
        print('intel cpu run')
class AmdCpu(CPU):
    def run(self):
        print('amd cpu run')

# 抽象工厂类
class CpuFactory(metaclass=ABCMeta):
    @abstractclassmethod
    def create_cpu(self):
        pass

# 具体工厂类, 用于创建具体产品
class IntelCpuFactory(CpuFactory):
    def create_cpu(self):
        return IntelCpu()

class AmdCpuFactory(CpuFactory):
    def create_cpu(self):
        return AmdCpu()

#################　使用  ###############
f = IntelCpuFactory()
cpu = f.create_cpu()
cpu.run()

f = AmdCpuFactory()
cpu = f.create_cpu()
cpu.run()
```

#### 优点

<font color="red">每个具体产品都对应一个具体工厂类M</font>，不需要修改工厂类代码；隐藏了对象创建的实现细节.

#### 缺点

每增加一个具体产品类，就必须增加一个相应的具体工厂类。其实个人理解，这是这个模式优点带来的缺点罢了。

### 抽象工厂模式

#### 解决的问题

之前的工厂方法模式只产生一个对象，抽象工厂模式要解决的是一次性产生由多个组件对象组成的对象。比如说我想生产一部手机，手机零件有手机壳、CPU等小部件组成。抽象工厂模式与工厂方法模式最大的区别：抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类。

#### 使用步骤

- 创建**抽象组件类** & 定义具体组件的公共接口；
- 创建**具体组件类**(继承抽象产品类) & 定义生产的具体组件；
- 创建**抽象工厂类** & 定义生产产品的公共接口，这里的抽象工厂里多个接口用于生产多个组件
- 创建具体工厂类 & 创建多个具体的组件，创建的组件可以用来组成成一个产品
- 创建一个组件包装类，构造方法接收各个组件成一个产品，可以调用相应的方法
- 提供一个方法，接收工厂对象，用于生成产品对象。

#### 实例

````python
from abc import abstractmethod,ABCMeta

#==============抽象组件============
class PhoneShell(metaclass=ABCMeta):
    '''手机壳'''
    @abstractmethod
    def show_shell(self):
        pass

class CPU(metaclass=ABCMeta):
    '''CPU'''
    @abstractmethod
    def show_cpu(self):
        pass

class OS(metaclass=ABCMeta):
    '''操作系统'''
    @abstractmethod
    def show_os(self):
        pass

# =================具体组件==============
class SmallShell(PhoneShell):
    def show_shell(self):
        print('普通手机小手机壳')

class BigShell(PhoneShell):
    def show_shell(self):
        print('普通手机大手机壳')

class AppleShell(PhoneShell):
    def show_shell(self):
        print('苹果手机壳')

class YingTeerCPU(CPU):
    def show_cpu(self):
        print('英特尔cpu')

class MediaCPU(CPU):
    def show_cpu(self):
        print('联发科cpu')

class AppleCPU(CPU):
    def show_cpu(self):
        print('苹果cpu')

class Android(OS):
    def show_os(self):
        print('Android系统')

class IOS(OS):
    def show_os(self):
        print('ios系统')

# ===============抽象工厂==============
class PhoneFactory(metaclass=ABCMeta):
    @abstractmethod
    def make_shell(self):
        '''制作手机壳'''
        pass

    @abstractmethod
    def make_cpu(self):
        '''制作cpu'''
        pass

    @abstractmethod
    def make_os(self):
        '''制作手机壳'''
        pass

# ==============具体工厂================
class MiFactory(PhoneFactory):
    def make_shell(self):
        return SmallShell()

    def make_cpu(self):
        return AppleCPU()

    def make_os(self):
        return Android()

class HuaWeiactory(PhoneFactory):
    def make_shell(self):
        return BigShell()

    def make_cpu(self):
        return YingTeerCPU()

    def make_os(self):
        return Android()

# ===============使用===============
class Phone:
    def __init__(self,cpu,os,shell):
        self.cpu = cpu
        self.os = os
        self.shell = shell

    def show_info(self):
        print('手机信息')
        self.cpu.show_cpu()
        self.os.show_os()
        self.shell.show_shell()

def make_phone(factory):
    cpu = factory.make_cpu()
    os = factory.make_os()
    shell = factory.make_shell()
    return Phone(cpu,os,shell)

p1 = make_phone(HuaWeiactory())
p1.show_info()

p2 = make_phone(MiFactory())
p2.show_info()
````

#### 优点

暂时没get到。

#### 缺点

抽象工厂模式很难支持新种类产品的变化。
这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。

## 单例模式

实现1个类只有1个实例化对象。单例模式的作用优点类似于全局变量。

最简单的实现方式是通过静态字段加重写`__new__`方法即可。

## 建造者模式

### 解决的问题

将一个复杂对象的构建与它表示分离，使得同样的构建过程可以创建不同的表示。例如，创建一个人对象，这个对象的属性可能是有不同表示，有黑人，黄种人，白人等，有胖子和瘦子等。

### 使用步骤

* 产品类，也就是需要构造的复杂对象，这个对象的属性通过参数传入构造方法且属性可以是动态的
* 建造者基类，用于定义创建对象属性的接口
* 具体建造者，用于创建具体的对象属性
* 指挥者类，接收具体建造者，控制建造者的建造顺序

对上面的使用理解：

1. 指挥者（Director）直接和客户（Client）进行需求沟通；
2. 沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）；
3. 将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）；
4. 各个具体建造者负责进行产品部件的构建；
5. 最终构建成具体产品(Product).

```python
import random
from abc import abstractmethod, ABCMeta

#------产品------

class Player:
    def __init__(self, face=None, body=None, arm=None, leg=None):
        self.face = face
        self.arm = arm
        self.leg = leg
        self.body = body

    def __str__(self):
        return "%s, %s, %s, %s" % (self.face, self.arm, self.body, self.leg)


#------建造者------


class PlayerBuilder(metaclass=ABCMeta):
    @abstractmethod
    def build_face(self):
        pass
    @abstractmethod
    def build_arm(self):
        pass
    @abstractmethod
    def build_leg(self):
        pass
    @abstractmethod
    def build_body(self):
        pass
    @abstractmethod
    def get_player(self):
        pass


class BeautifulWomanBuilder(PlayerBuilder):
    def __init__(self):
        self.player = Player()
    def build_face(self):
        self.player.face = "漂亮脸蛋"
    def build_arm(self):
        self.player.arm="细胳膊"
    def build_body(self):
        self.player.body="细腰"
    def build_leg(self):
        self.player.leg="长腿"
    def get_player(self):
        return self.player

class RandomPlayerBuilder(PlayerBuilder):
    def __init__(self):
        self.player = Player()
    def build_face(self):
        self.player.face = random.choice(["瓜子脸","西瓜子脸"])
    def build_arm(self):
        self.player.arm=random.choice(["长胳膊","短胳膊"])
    def build_body(self):
        self.player.body=random.choice(["苗条","胖"])
    def build_leg(self):
        self.player.leg=random.choice(["长腿","短腿"])
    def get_player(self):
        return self.player

class PlayerDirector:
    def __init__(self, builder):
        self.builder = builder
    # 控制组装顺序
    def build_player(self):
        self.builder.build_body()
        self.builder.build_face()
        self.builder.build_arm()
        self.builder.build_leg()
        return self.builder.get_player()


pd = PlayerDirector(RandomPlayerBuilder())
p = pd.build_player()
print(p)
```

总结： 依赖于继承的创建型模式：工厂方法模式；依赖于组合的创建型模式：抽象工厂模式，创建者模式







